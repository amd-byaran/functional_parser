/**
 * @file groups_parser.cpp
 * @brief Implementation of the Groups parser for coverage analysis
 * 
 * This file contains the implementation of the GroupsParser class which
 * parses groups.txt files generated by URG (Unified Report Generator).
 * These files contain detailed testbench coverage group information including:
 * - Individual group coverage metrics
 * - Group configuration (weight, goal, instances)
 * - Coverage bins and auto-generation settings
 * - Comments and hierarchical group names
 * 
 * OUTPUT DATA STRUCTURE:
 * The parser creates CoverageGroup objects with the following structure:
 * {
 *   name: "tb.dco_rsmu_master_if::axi_wr_interchannels_cov"  // Full hierarchical group name
 *   comment: ""                                               // Optional comment/description
 *   coverage: {                                              // Basic coverage metrics
 *     covered: 0,
 *     expected: 16,
 *     score: 0.00,
 *     is_valid: true
 *   },
 *   instance_coverage: {                                     // Per-instance coverage
 *     covered: 0,
 *     expected: 0,
 *     score: 0.00,
 *     is_valid: true
 *   },
 *   instances: 0,                                            // Number of instances
 *   weight: 1,                                               // Coverage weight
 *   goal: 100,                                               // Coverage goal percentage
 *   at_least: 1,                                             // Minimum required hits
 *   per_instance: 1,                                         // Per-instance requirement
 *   auto_bin_max: 64,                                        // Automatic bin maximum
 *   print_missing: 64,                                       // Print missing coverage flag
 *   is_auto_generated: false                                 // Auto-generated group flag
 * }
 * 
 * PARSING ALGORITHM:
 * 1. Parse header section for summary statistics
 * 2. Parse individual group entries line by line
 * 3. Extract coverage metrics, configuration, and metadata
 * 4. Store each group in the database hash table
 * 
 * EXAMPLE GROUPS FORMAT:
 * ```
 * Testbench Group List
 * 
 * Total Groups Coverage Summary 
 * COVERED EXPECTED SCORE  COVERED EXPECTED INST SCORE WEIGHT 
 * 134908  328987    41.01 149893  371029    40.40     1      
 * 
 * Total groups in report: 16295
 * -------------------------------------------------------------------------------
 * COVERED EXPECTED SCORE  INSTANCES WEIGHT GOAL   AT LEAST PER INSTANCE AUTO BIN MAX PRINT MISSING COMMENT NAME
 * 0       16         0.00   0.00    1      100    1        1            64           64                    tb.dco_rsmu_master_if::axi_wr_interchannels_cov
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Parse groups file
 * GroupsParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("groups.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     std::cout << "Successfully parsed " << db.get_num_groups() << " groups" << std::endl;
 *     
 *     // Find specific group
 *     auto group = db.find_coverage_group("tb.cpu.alu::arithmetic_ops");
 *     if (group) {
 *         std::cout << "Group: " << group->name << std::endl;
 *         std::cout << "Coverage: " << group->coverage.score << "%" << std::endl;
 *         std::cout << "Weight: " << group->weight << std::endl;
 *         std::cout << "Goal: " << group->goal << "%" << std::endl;
 *         
 *         if (group->meets_goal()) {
 *             std::cout << "âœ“ Goal achieved!" << std::endl;
 *         }
 *     }
 *     
 *     // Find uncovered groups
 *     auto uncovered = db.get_uncovered_groups();
 *     std::cout << "Uncovered groups: " << uncovered.size() << std::endl;
 *     for (const auto* group : uncovered) {
 *         std::cout << "  " << group->name << std::endl;
 *     }
 * }
 * ```
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 */

#include "functional_coverage_parser.h"
#include <sstream>
#include <regex>
#include <iomanip>
#include <algorithm>

namespace coverage_parser {

/**
 * @brief Parse a groups coverage file
 * 
 * Main entry point for parsing groups.txt files. Orchestrates the parsing
 * of the header section and individual group entries.
 * 
 * @param filename Path to the groups file
 * @param db Database to populate with parsed data
 * @return ParserResult indicating success or failure
 */
ParserResult GroupsParser::parse(const std::string& filename, CoverageDatabase& db) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return ParserResult::ERROR_FILE_NOT_FOUND;
    }
    
    // Parse header section to get summary information
    ParserResult result = parse_header_section(file);
    if (result != ParserResult::SUCCESS) {
        return result;
    }
    
    std::string line;
    std::uint32_t groups_parsed = 0;
    std::uint32_t parse_errors = 0;
    
    // Parse individual group entries
    while (std::getline(file, line)) {
        // Skip empty lines and separators
        if (line.empty() || line.find("---") != std::string::npos) {
            continue;
        }
        
        // Skip header lines
        if (is_header_line(line)) {
            continue;
        }
        
        // Parse group data line
        if (is_group_data_line(line)) {
            result = parse_group_entry(line, db);
            if (result == ParserResult::SUCCESS) {
                groups_parsed++;
            } else {
                parse_errors++;
                
                // If too many parse errors, fail
                if (parse_errors > 10) {
                    return ParserResult::ERROR_PARSE_FAILED;
                }
            }
            
            // Check if we've reached the configured maximum
            if (config_.max_groups > 0 && groups_parsed >= config_.max_groups) {
                break;
            }
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse the header section containing summary statistics
 * 
 * Parses the initial section of the groups file containing:
 * - Total groups coverage summary
 * - Instance coverage summary
 * - Total number of groups in report
 * 
 * @param file Input file stream
 * @return ParserResult indicating success or failure
 */
ParserResult GroupsParser::parse_header_section(std::ifstream& file) {
    std::string line;
    bool found_title = false;
    
    // Look for "Testbench Group List" title
    while (std::getline(file, line)) {
        if (line.find("Testbench Group List") != std::string::npos ||
            line.find("Group List") != std::string::npos) {
            found_title = true;
            break;
        }
    }
    
    if (!found_title) {
        return ParserResult::ERROR_INVALID_FORMAT;
    }
    
    // Skip to the actual data section header
    while (std::getline(file, line)) {
        if (line.find("COVERED EXPECTED SCORE") != std::string::npos &&
            line.find("NAME") != std::string::npos) {
            // Found the data section header, we're ready to parse group entries
            break;
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse a single group entry line
 * 
 * Parses a line containing coverage group data and creates a CoverageGroup
 * object to store in the database.
 * 
 * Expected format:
 * COVERED EXPECTED SCORE INSTANCES WEIGHT GOAL AT_LEAST PER_INSTANCE AUTO BIN_MAX PRINT_MISSING COMMENT NAME
 * 
 * @param line Line containing group data
 * @param db Database to store the parsed group
 * @return ParserResult indicating success or failure
 */
ParserResult GroupsParser::parse_group_entry(const std::string& line, CoverageDatabase& db) {
    try {
        std::vector<std::string> tokens = split_group_line(line);
        
        // Need at least 12 fields for a valid group entry
        if (tokens.size() < 12) {
            return ParserResult::ERROR_INVALID_FORMAT;
        }
        
        auto group = std::make_unique<CoverageGroup>();
        
        // Parse basic coverage metrics
        group->coverage.covered = std::stoul(tokens[0]);
        group->coverage.expected = std::stoul(tokens[1]);
        group->coverage.score = std::stod(tokens[2]);
        group->coverage.is_valid = true;
        
        // Parse instance coverage if available
        if (tokens.size() > 4 && !tokens[3].empty() && tokens[3] != "--") {
            group->instance_coverage.score = std::stod(tokens[3]);
            group->instance_coverage.is_valid = true;
        }
        
        // Parse configuration parameters
        group->instances = std::stoul(tokens[4]);
        group->weight = std::stoul(tokens[5]);
        group->goal = std::stoul(tokens[6]);
        group->at_least = std::stoul(tokens[7]);
        group->per_instance = std::stoul(tokens[8]);
        group->auto_bin_max = std::stoul(tokens[9]);
        group->print_missing = std::stoul(tokens[10]);
        
        // Parse comment (optional field)
        if (tokens.size() > 11 && config_.parse_comments) {
            group->comment = tokens[11];
        }
        
        // Parse group name (last field)
        if (tokens.size() > 12) {
            group->name = tokens[12];
        } else {
            // If no separate name field, the comment might contain the name
            group->name = group->comment;
            group->comment.clear();
        }
        
        // Skip empty groups if configured
        if (config_.ignore_empty_groups && group->coverage.expected == 0) {
            return ParserResult::SUCCESS;
        }
        
        // Skip groups below coverage threshold
        if (group->coverage.score < config_.min_coverage_threshold) {
            return ParserResult::SUCCESS;
        }
        
        // Determine if this is an auto-generated group
        group->is_auto_generated = (group->name.find("::") != std::string::npos) ||
                                   (group->name.find("_cg") != std::string::npos) ||
                                   (group->auto_bin_max > 0);
        
        // Add to database
        db.add_coverage_group(std::move(group));
        
        return ParserResult::SUCCESS;
        
    } catch (const std::exception& e) {
        return ParserResult::ERROR_PARSE_FAILED;
    }
}

/**
 * @brief Check if a line contains group data
 * 
 * Determines if the given line contains numerical coverage group data
 * rather than headers, separators, or comments.
 * 
 * @param line Line to check
 * @return true if line contains group data, false otherwise
 */
bool GroupsParser::is_group_data_line(const std::string& line) const {
    // Skip obvious non-data lines
    if (line.empty() || line[0] == '-' || line.find("COVERED") != std::string::npos) {
        return false;
    }
    
    // Look for pattern: starts with numbers
    std::regex data_pattern(R"(\s*\d+\s+\d+\s+[\d\-\.]+.*)");
    return std::regex_match(line, data_pattern);
}

/**
 * @brief Check if a line is a header line
 * 
 * Determines if the given line is a header/title line in the groups file.
 * 
 * @param line Line to check
 * @return true if line is a header, false otherwise
 */
bool GroupsParser::is_header_line(const std::string& line) const {
    return line.find("Testbench Group List") != std::string::npos ||
           line.find("Total Groups Coverage Summary") != std::string::npos ||
           line.find("Total groups in report") != std::string::npos ||
           line.find("COVERED EXPECTED SCORE") != std::string::npos ||
           line.find("INSTANCES WEIGHT GOAL") != std::string::npos ||
           line.find("NAME") != std::string::npos;
}

/**
 * @brief Split a group line into tokens
 * 
 * Splits a coverage group data line into individual fields, handling
 * various whitespace and formatting issues commonly found in coverage reports.
 * 
 * This function implements intelligent parsing that:
 * - Handles multiple spaces between fields
 * - Preserves quoted strings
 * - Deals with missing fields (represented as "--")
 * - Handles hierarchical names with embedded spaces
 * 
 * @param line Line to split
 * @return Vector of tokens
 */
std::vector<std::string> GroupsParser::split_group_line(const std::string& line) const {
    std::vector<std::string> tokens;
    std::istringstream iss(line);
    std::string token;
    
    // Split by whitespace, but preserve the last token (name) which may contain spaces
    std::vector<std::string> all_tokens;
    while (iss >> token) {
        all_tokens.push_back(token);
    }
    
    if (all_tokens.size() < 12) {
        return all_tokens; // Return as-is if too few tokens
    }
    
    // Take the first 11 tokens as separate fields
    for (size_t i = 0; i < 11 && i < all_tokens.size(); ++i) {
        tokens.push_back(all_tokens[i]);
    }
    
    // Combine remaining tokens as the group name
    if (all_tokens.size() > 11) {
        std::string group_name;
        for (size_t i = 11; i < all_tokens.size(); ++i) {
            if (i > 11) group_name += " ";
            group_name += all_tokens[i];
        }
        tokens.push_back(group_name);
    }
    
    return tokens;
}

} // namespace coverage_parser