/**
 * @file hierarchy_parser.cpp
 * @brief Implementation of the Hierarchy parser for coverage analysis
 * 
 * This file contains the implementation of the HierarchyParser class which
 * parses hierarchy.txt files generated by URG (Unified Report Generator).
 * These files contain design hierarchy coverage information including:
 * - Individual instance coverage metrics
 * - Hierarchical instance paths
 * - Module/block names
 * - Assertion coverage per instance
 * 
 * PARSING ALGORITHM:
 * 1. Skip header section with title and column headers
 * 2. Parse individual hierarchy entries line by line
 * 3. Extract instance paths, coverage metrics, and module names
 * 4. Calculate hierarchy depth levels
 * 5. Store each instance in the database hash table
 * 
 * EXAMPLE HIERARCHY FORMAT:
 * ```
 * Design Hierarchy
 * 
 * ----------------
 * SCORE   ASSERT                                                                                                                                                                        
 *   0.00    0.00 0/66   dcec_dc.dchubbubl.udchubbubl.uRET_PATH.udchubbub_ret_path_compbuf.udchubbub_ret_path_compbuf_metafifo.umetafifo_ram.mem_0_0.PDP                                 
 *   0.00    0.00 0/66   dcec_dc.dchubbubl.udchubbubl.uRET_PATH.udchubbub_ret_path_compbuf.udchubbub_ret_path_compbuf_metafifo.umetafifo_ram.mem_10_0.PDP
 * ```
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 */

#include "functional_coverage_parser.h"
#include <sstream>
#include <regex>
#include <algorithm>

namespace coverage_parser {

/**
 * @brief Parse a hierarchy coverage file
 * 
 * Main entry point for parsing hierarchy.txt files. Processes the header
 * section and then parses individual hierarchy instance entries.
 * 
 * @param filename Path to the hierarchy file
 * @param db Database to populate with parsed data
 * @return ParserResult indicating success or failure
 */
ParserResult HierarchyParser::parse(const std::string& filename, CoverageDatabase& db) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return ParserResult::ERROR_FILE_NOT_FOUND;
    }
    
    std::string line;
    std::uint32_t instances_parsed = 0;
    std::uint32_t parse_errors = 0;
    bool found_data_section = false;
    
    // Skip header and find data section
    while (std::getline(file, line)) {
        if (line.find("SCORE") != std::string::npos && 
            line.find("ASSERT") != std::string::npos) {
            found_data_section = true;
            break;
        }
    }
    
    if (!found_data_section) {
        return ParserResult::ERROR_INVALID_FORMAT;
    }
    
    // Parse individual hierarchy entries
    while (std::getline(file, line)) {
        // Skip empty lines and separators
        if (line.empty() || line.find("---") != std::string::npos) {
            continue;
        }
        
        // Skip header lines
        if (is_header_line(line)) {
            continue;
        }
        
        // Parse hierarchy data line
        if (is_hierarchy_data_line(line)) {
            ParserResult result = parse_hierarchy_entry(line, db);
            if (result == ParserResult::SUCCESS) {
                instances_parsed++;
            } else {
                parse_errors++;
                
                // If too many parse errors, fail
                if (parse_errors > 20) {
                    return ParserResult::ERROR_PARSE_FAILED;
                }
            }
            
            // Check if we've reached the configured maximum
            if (config_.max_instances > 0 && instances_parsed >= config_.max_instances) {
                break;
            }
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse a single hierarchy entry line
 * 
 * Parses a line containing hierarchy instance data and creates a HierarchyInstance
 * object to store in the database.
 * 
 * Expected format:
 * SCORE ASSERT_SCORE ASSERT_COVERED/ASSERT_EXPECTED INSTANCE_PATH
 * 
 * @param line Line containing hierarchy data
 * @param db Database to store the parsed instance
 * @return ParserResult indicating success or failure
 */
ParserResult HierarchyParser::parse_hierarchy_entry(const std::string& line, CoverageDatabase& db) {
    try {
        std::vector<std::string> tokens = split_hierarchy_line(line);
        
        // Need at least 4 fields for a valid hierarchy entry
        if (tokens.size() < 4) {
            return ParserResult::ERROR_INVALID_FORMAT;
        }
        
        auto instance = std::make_unique<HierarchyInstance>();
        
        // Parse coverage scores
        instance->total_score = std::stod(tokens[0]);
        instance->assert_coverage.score = std::stod(tokens[1]);
        
        // Parse assert coverage fraction (format: "covered/expected")
        std::string assert_fraction = tokens[2];
        size_t slash_pos = assert_fraction.find('/');
        if (slash_pos != std::string::npos) {
            instance->assert_coverage.covered = std::stoul(assert_fraction.substr(0, slash_pos));
            instance->assert_coverage.expected = std::stoul(assert_fraction.substr(slash_pos + 1));
            instance->assert_coverage.is_valid = true;
        }
        
        // Extract instance path (remaining tokens)
        std::string instance_path;
        for (size_t i = 3; i < tokens.size(); ++i) {
            if (i > 3) instance_path += " ";
            instance_path += tokens[i];
        }
        instance->instance_path = instance_path;
        
        // Calculate hierarchy depth and extract module name
        instance->depth_level = calculate_depth_level(instance->instance_path);
        instance->extract_module_name();
        
        // Determine if this is a leaf instance (heuristic based on path structure)
        instance->is_leaf_instance = (instance->instance_path.find(".mem_") != std::string::npos ||
                                      instance->instance_path.find(".PDP") != std::string::npos ||
                                      instance->instance_path.find("_0") != std::string::npos ||
                                      instance->instance_path.find("_1") != std::string::npos);
        
        // Skip instances below coverage threshold if configured
        if (instance->total_score < config_.min_coverage_threshold) {
            return ParserResult::SUCCESS;
        }
        
        // Add to database
        db.add_hierarchy_instance(std::move(instance));
        
        return ParserResult::SUCCESS;
        
    } catch (const std::exception& e) {
        return ParserResult::ERROR_PARSE_FAILED;
    }
}

/**
 * @brief Check if a line contains hierarchy data
 * 
 * Determines if the given line contains numerical hierarchy instance data
 * rather than headers, separators, or comments.
 * 
 * @param line Line to check
 * @return true if line contains hierarchy data, false otherwise
 */
bool HierarchyParser::is_hierarchy_data_line(const std::string& line) const {
    // Skip obvious non-data lines
    if (line.empty() || line[0] == '-' || line.find("SCORE") != std::string::npos) {
        return false;
    }
    
    // Look for pattern: starts with decimal numbers followed by instance path
    std::regex data_pattern(R"(\s*\d+\.\d+\s+\d+\.\d+\s+\d+/\d+\s+.+)");
    return std::regex_match(line, data_pattern);
}

/**
 * @brief Check if a line is a header line
 * 
 * Determines if the given line is a header/title line in the hierarchy file.
 * 
 * @param line Line to check
 * @return true if line is a header, false otherwise
 */
bool HierarchyParser::is_header_line(const std::string& line) const {
    return line.find("Design Hierarchy") != std::string::npos ||
           line.find("SCORE") != std::string::npos ||
           line.find("ASSERT") != std::string::npos ||
           line.find("Hierarchical") != std::string::npos;
}

/**
 * @brief Split a hierarchy line into tokens
 * 
 * Splits a hierarchy instance data line into individual fields, handling
 * various whitespace and formatting issues.
 * 
 * @param line Line to split
 * @return Vector of tokens
 */
std::vector<std::string> HierarchyParser::split_hierarchy_line(const std::string& line) const {
    std::vector<std::string> tokens;
    std::istringstream iss(line);
    std::string token;
    
    // The first three tokens are numeric fields
    for (int i = 0; i < 3 && iss >> token; ++i) {
        tokens.push_back(token);
    }
    
    // The rest is the instance path (may contain spaces in some formats)
    std::string remaining_line;
    std::getline(iss, remaining_line);
    
    if (!remaining_line.empty()) {
        // Trim leading whitespace
        remaining_line.erase(0, remaining_line.find_first_not_of(" \t"));
        
        if (!remaining_line.empty()) {
            tokens.push_back(remaining_line);
        }
    }
    
    return tokens;
}

/**
 * @brief Calculate hierarchy depth level from instance path
 * 
 * Determines the depth level in the design hierarchy by counting
 * the number of dots ('.') in the instance path.
 * 
 * @param instance_path Full hierarchical instance path
 * @return Depth level (0 = top level, 1 = first level down, etc.)
 */
std::uint32_t HierarchyParser::calculate_depth_level(const std::string& instance_path) const {
    return static_cast<std::uint32_t>(std::count(instance_path.begin(), instance_path.end(), '.'));
}

} // namespace coverage_parser