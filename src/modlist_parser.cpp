/**
 * @file modlist_parser.cpp
 * @brief Implementation of the Module List parser for coverage analysis
 * 
 * This file contains the implementation of the ModuleListParser class which
 * parses modlist.txt files generated by URG (Unified Report Generator).
 * These files contain module definition coverage information including:
 * - Module-level coverage aggregation
 * - Coverage metrics per module type
 * - Module definition names
 * - Instance counts per module
 * 
 * PARSING ALGORITHM:
 * 1. Skip header section with summary statistics
 * 2. Parse individual module entries line by line
 * 3. Extract module names and coverage metrics
 * 4. Store each module definition in the database hash table
 * 
 * EXAMPLE MODLIST FORMAT:
 * ```
 * Design Module List
 * 
 * Total Module Definition Coverage Summary 
 * SCORE   ASSERT            
 *  39.19   39.19 9347/23853 
 * 
 * Total modules in report: 1218
 * -------------------------------------------------------------------------------
 * SCORE   ASSERT          NAME                                                   
 *   0.00    0.00 0/1      az_memory_allocation_disallocation_collision           
 *   0.00    0.00 0/4      hvm_ffbm_tlb_mem1p32768x24bls                          
 * ```
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 */

#include "functional_coverage_parser.h"
#include <sstream>
#include <regex>
#include <algorithm>

namespace coverage_parser {

/**
 * @brief Parse a module list coverage file
 * 
 * Main entry point for parsing modlist.txt files. Processes the header
 * section and then parses individual module definition entries.
 * 
 * @param filename Path to the module list file
 * @param db Database to populate with parsed data
 * @return ParserResult indicating success or failure
 */
ParserResult ModuleListParser::parse(const std::string& filename, CoverageDatabase& db) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return ParserResult::ERROR_FILE_NOT_FOUND;
    }
    
    std::string line;
    std::uint32_t modules_parsed = 0;
    std::uint32_t parse_errors = 0;
    bool found_data_section = false;
    
    // Skip header and find data section
    while (std::getline(file, line)) {
        if (line.find("SCORE") != std::string::npos && 
            line.find("ASSERT") != std::string::npos && 
            line.find("NAME") != std::string::npos) {
            found_data_section = true;
            break;
        }
    }
    
    if (!found_data_section) {
        return ParserResult::ERROR_INVALID_FORMAT;
    }
    
    // Parse individual module entries
    while (std::getline(file, line)) {
        // Skip empty lines and separators
        if (line.empty() || line.find("---") != std::string::npos) {
            continue;
        }
        
        // Skip header lines
        if (is_header_line(line)) {
            continue;
        }
        
        // Parse module data line
        if (is_module_data_line(line)) {
            ParserResult result = parse_module_entry(line, db);
            if (result == ParserResult::SUCCESS) {
                modules_parsed++;
            } else {
                parse_errors++;
                
                // If too many parse errors, fail
                if (parse_errors > 10) {
                    return ParserResult::ERROR_PARSE_FAILED;
                }
            }
            
            // Check if we've reached the configured maximum
            if (config_.max_instances > 0 && modules_parsed >= config_.max_instances) {
                break;
            }
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse a single module entry line
 * 
 * Parses a line containing module definition data and creates a ModuleDefinition
 * object to store in the database.
 * 
 * Expected format:
 * SCORE ASSERT_SCORE ASSERT_COVERED/ASSERT_EXPECTED MODULE_NAME
 * 
 * @param line Line containing module data
 * @param db Database to store the parsed module
 * @return ParserResult indicating success or failure
 */
ParserResult ModuleListParser::parse_module_entry(const std::string& line, CoverageDatabase& db) {
    try {
        std::vector<std::string> tokens = split_module_line(line);
        
        // Need at least 4 fields for a valid module entry
        if (tokens.size() < 4) {
            return ParserResult::ERROR_INVALID_FORMAT;
        }
        
        auto module = std::make_unique<ModuleDefinition>();
        
        // Parse coverage scores
        module->total_score = std::stod(tokens[0]);
        module->assert_coverage.score = std::stod(tokens[1]);
        
        // Parse assert coverage fraction (format: "covered/expected")
        std::string assert_fraction = tokens[2];
        size_t slash_pos = assert_fraction.find('/');
        if (slash_pos != std::string::npos) {
            module->assert_coverage.covered = std::stoul(assert_fraction.substr(0, slash_pos));
            module->assert_coverage.expected = std::stoul(assert_fraction.substr(slash_pos + 1));
            module->assert_coverage.is_valid = true;
        }
        
        // Extract module name (remaining tokens)
        std::string module_name;
        for (size_t i = 3; i < tokens.size(); ++i) {
            if (i > 3) module_name += " ";
            module_name += tokens[i];
        }
        module->module_name = module_name;
        
        // Initialize instance counts (these would be calculated separately)
        module->instance_count = 1; // At least one instance exists if it's in the report
        module->covered_instances = module->assert_coverage.covered > 0 ? 1 : 0;
        
        // Skip modules below coverage threshold if configured
        if (module->total_score < config_.min_coverage_threshold) {
            return ParserResult::SUCCESS;
        }
        
        // Skip empty modules if configured
        if (config_.ignore_empty_groups && module->assert_coverage.expected == 0) {
            return ParserResult::SUCCESS;
        }
        
        // Add to database
        db.add_module_definition(std::move(module));
        
        return ParserResult::SUCCESS;
        
    } catch (const std::exception& e) {
        return ParserResult::ERROR_PARSE_FAILED;
    }
}

/**
 * @brief Check if a line contains module data
 * 
 * Determines if the given line contains numerical module definition data
 * rather than headers, separators, or comments.
 * 
 * @param line Line to check
 * @return true if line contains module data, false otherwise
 */
bool ModuleListParser::is_module_data_line(const std::string& line) const {
    // Skip obvious non-data lines
    if (line.empty() || line[0] == '-' || line.find("SCORE") != std::string::npos) {
        return false;
    }
    
    // Look for pattern: starts with decimal numbers followed by module name
    std::regex data_pattern(R"(\s*\d+\.\d+\s+\d+\.\d+\s+\d+/\d+\s+.+)");
    return std::regex_match(line, data_pattern);
}

/**
 * @brief Check if a line is a header line
 * 
 * Determines if the given line is a header/title line in the module list file.
 * 
 * @param line Line to check
 * @return true if line is a header, false otherwise
 */
bool ModuleListParser::is_header_line(const std::string& line) const {
    return line.find("Design Module List") != std::string::npos ||
           line.find("Total Module Definition Coverage Summary") != std::string::npos ||
           line.find("Total modules in report") != std::string::npos ||
           line.find("SCORE") != std::string::npos ||
           line.find("ASSERT") != std::string::npos ||
           line.find("NAME") != std::string::npos;
}

/**
 * @brief Split a module line into tokens
 * 
 * Splits a module definition data line into individual fields, handling
 * various whitespace and formatting issues.
 * 
 * The module name field can contain spaces and complex characters, so we need
 * to be careful when splitting the line.
 * 
 * @param line Line to split
 * @return Vector of tokens
 */
std::vector<std::string> ModuleListParser::split_module_line(const std::string& line) const {
    std::vector<std::string> tokens;
    std::istringstream iss(line);
    std::string token;
    
    // The first three tokens are numeric fields
    for (int i = 0; i < 3 && iss >> token; ++i) {
        tokens.push_back(token);
    }
    
    // The rest is the module name (may contain spaces and special characters)
    std::string remaining_line;
    std::getline(iss, remaining_line);
    
    if (!remaining_line.empty()) {
        // Trim leading whitespace
        remaining_line.erase(0, remaining_line.find_first_not_of(" \t"));
        
        // Trim trailing whitespace
        remaining_line.erase(remaining_line.find_last_not_of(" \t") + 1);
        
        if (!remaining_line.empty()) {
            tokens.push_back(remaining_line);
        }
    }
    
    return tokens;
}

} // namespace coverage_parser