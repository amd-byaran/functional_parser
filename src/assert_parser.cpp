/**
 * @file assert_parser.cpp
 * @brief Implementation of the Assert parser for coverage analysis
 * 
 * This file contains the implementation of the AssertParser class which
 * parses asserts.txt files generated by URG (Unified Report Generator).
 * These files contain individual assertion coverage information including:
 * - Assertion names and identifiers
 * - Coverage status and hit counts
 * - Source file locations and line numbers
 * - Assertion messages and severity levels
 * - Instance paths where assertions exist
 * 
 * PARSING ALGORITHM:
 * 1. Skip header section with summary statistics
 * 2. Parse individual assertion entries line by line
 * 3. Extract assertion metadata and coverage status
 * 4. Store each assertion in the database hash table
 * 
 * EXAMPLE ASSERT FORMAT:
 * ```
 * Assertion Coverage Report
 * 
 * Total Assertions: 23853
 * Covered: 9347
 * Coverage: 39.19%
 * 
 * -------------------------------------------------------------------------------
 * STATUS  HITS    ASSERTION                           INSTANCE                    FILE:LINE
 * PASS    1234    check_valid_transaction             tb.cpu.alu                  alu.sv:45
 * FAIL    0       check_data_integrity                tb.mem.ctrl                 mem_ctrl.sv:123
 * ```
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 */

#include "functional_coverage_parser.h"
#include <sstream>
#include <regex>
#include <algorithm>

namespace coverage_parser {

/**
 * @brief Parse an assertions coverage file
 * 
 * Main entry point for parsing asserts.txt files. Processes the header
 * section and then parses individual assertion entries.
 * 
 * @param filename Path to the assertions file
 * @param db Database to populate with parsed data
 * @return ParserResult indicating success or failure
 */
ParserResult AssertParser::parse(const std::string& filename, CoverageDatabase& db) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return ParserResult::ERROR_FILE_NOT_FOUND;
    }
    
    std::string line;
    std::uint32_t asserts_parsed = 0;
    std::uint32_t parse_errors = 0;
    bool found_data_section = false;
    
    // Skip header and find data section
    while (std::getline(file, line)) {
        if (line.find("STATUS") != std::string::npos && 
            line.find("ASSERTION") != std::string::npos) {
            found_data_section = true;
            break;
        }
        
        // Alternative header format
        if (line.find("ASSERT") != std::string::npos && 
            line.find("NAME") != std::string::npos) {
            found_data_section = true;
            break;
        }
    }
    
    if (!found_data_section) {
        // Try to parse without explicit header (some formats may not have headers)
        file.clear();
        file.seekg(0, std::ios::beg);
        found_data_section = true;
    }
    
    // Parse individual assertion entries
    while (std::getline(file, line)) {
        // Skip empty lines and separators
        if (line.empty() || line.find("---") != std::string::npos) {
            continue;
        }
        
        // Skip header lines
        if (is_header_line(line)) {
            continue;
        }
        
        // Parse assertion data line
        if (is_assert_data_line(line)) {
            ParserResult result = parse_assert_entry(line, db);
            if (result == ParserResult::SUCCESS) {
                asserts_parsed++;
            } else {
                parse_errors++;
                
                // If too many parse errors, fail
                if (parse_errors > 50) {
                    return ParserResult::ERROR_PARSE_FAILED;
                }
            }
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse a single assertion entry line
 * 
 * Parses a line containing assertion data and creates an AssertCoverage
 * object to store in the database.
 * 
 * Expected formats:
 * STATUS HITS ASSERTION_NAME INSTANCE_PATH FILE:LINE
 * or
 * COVERED/EXPECTED ASSERTION_NAME INSTANCE_PATH
 * 
 * @param line Line containing assertion data
 * @param db Database to store the parsed assertion
 * @return ParserResult indicating success or failure
 */
ParserResult AssertParser::parse_assert_entry(const std::string& line, CoverageDatabase& db) {
    try {
        std::vector<std::string> tokens = split_assert_line(line);
        
        // Need at least 3 fields for a valid assertion entry
        if (tokens.size() < 3) {
            return ParserResult::ERROR_INVALID_FORMAT;
        }
        
        auto assert_cov = std::make_unique<AssertCoverage>();
        
        // Determine format based on first token
        if (tokens[0] == "PASS" || tokens[0] == "FAIL" || tokens[0] == "COVERED" || tokens[0] == "UNCOVERED") {
            // Format: STATUS HITS ASSERTION_NAME INSTANCE_PATH FILE:LINE
            assert_cov->is_covered = (tokens[0] == "PASS" || tokens[0] == "COVERED");
            assert_cov->severity = tokens[0];
            
            if (tokens.size() > 1) {
                try {
                    assert_cov->hit_count = std::stoul(tokens[1]);
                } catch (...) {
                    assert_cov->hit_count = assert_cov->is_covered ? 1 : 0;
                }
            }
            
            if (tokens.size() > 2) {
                assert_cov->assert_name = tokens[2];
            }
            
            if (tokens.size() > 3) {
                assert_cov->instance_path = tokens[3];
            }
            
            if (tokens.size() > 4) {
                std::string file_line = tokens[4];
                size_t colon_pos = file_line.find_last_of(':');
                if (colon_pos != std::string::npos) {
                    assert_cov->file_location = file_line.substr(0, colon_pos);
                    try {
                        assert_cov->line_number = std::stoul(file_line.substr(colon_pos + 1));
                    } catch (...) {
                        assert_cov->line_number = 0;
                    }
                } else {
                    assert_cov->file_location = file_line;
                }
            }
        }
        else if (tokens[0].find('/') != std::string::npos) {
            // Format: COVERED/EXPECTED ASSERTION_NAME INSTANCE_PATH
            std::string coverage_fraction = tokens[0];
            size_t slash_pos = coverage_fraction.find('/');
            if (slash_pos != std::string::npos) {
                std::uint32_t covered = std::stoul(coverage_fraction.substr(0, slash_pos));
                std::uint32_t expected = std::stoul(coverage_fraction.substr(slash_pos + 1));
                assert_cov->is_covered = (covered > 0);
                assert_cov->hit_count = covered;
            }
            
            if (tokens.size() > 1) {
                assert_cov->assert_name = tokens[1];
            }
            
            if (tokens.size() > 2) {
                assert_cov->instance_path = tokens[2];
            }
        }
        else {
            // Simple format: ASSERTION_NAME INSTANCE_PATH STATUS
            assert_cov->assert_name = tokens[0];
            
            if (tokens.size() > 1) {
                assert_cov->instance_path = tokens[1];
            }
            
            if (tokens.size() > 2) {
                assert_cov->is_covered = (tokens[2] == "COVERED" || tokens[2] == "PASS" || tokens[2] == "1");
                assert_cov->hit_count = assert_cov->is_covered ? 1 : 0;
            }
        }
        
        // Set default severity if not specified
        if (assert_cov->severity.empty()) {
            assert_cov->severity = assert_cov->is_covered ? "PASS" : "FAIL";
        }
        
        // Generate a unique key for the assertion
        if (assert_cov->assert_name.empty()) {
            // If no name provided, use instance path + line number
            assert_cov->assert_name = assert_cov->instance_path + "_" + std::to_string(assert_cov->line_number);
        }
        
        // Add to database
        db.add_assert_coverage(std::move(assert_cov));
        
        return ParserResult::SUCCESS;
        
    } catch (const std::exception& e) {
        return ParserResult::ERROR_PARSE_FAILED;
    }
}

/**
 * @brief Check if a line contains assertion data
 * 
 * Determines if the given line contains assertion coverage data
 * rather than headers, separators, or comments.
 * 
 * @param line Line to check
 * @return true if line contains assertion data, false otherwise
 */
bool AssertParser::is_assert_data_line(const std::string& line) const {
    // Skip obvious non-data lines
    if (line.empty() || line[0] == '-' || line.find("STATUS") != std::string::npos) {
        return false;
    }
    
    // Look for patterns that indicate assertion data
    // Pattern 1: STATUS HITS ...
    std::regex status_pattern(R"(\s*(PASS|FAIL|COVERED|UNCOVERED)\s+\d+\s+.+)");
    if (std::regex_match(line, status_pattern)) {
        return true;
    }
    
    // Pattern 2: covered/expected ...
    std::regex fraction_pattern(R"(\s*\d+/\d+\s+.+)");
    if (std::regex_match(line, fraction_pattern)) {
        return true;
    }
    
    // Pattern 3: General assertion line (contains alphanumeric and path-like strings)
    std::regex general_pattern(R"(\s*\w+.*\w+.*\w+.*)");
    return std::regex_match(line, general_pattern);
}

/**
 * @brief Check if a line is a header line
 * 
 * Determines if the given line is a header/title line in the assertions file.
 * 
 * @param line Line to check
 * @return true if line is a header, false otherwise
 */
bool AssertParser::is_header_line(const std::string& line) const {
    return line.find("Assertion Coverage Report") != std::string::npos ||
           line.find("Total Assertions") != std::string::npos ||
           line.find("Coverage:") != std::string::npos ||
           line.find("STATUS") != std::string::npos ||
           line.find("HITS") != std::string::npos ||
           line.find("ASSERTION") != std::string::npos ||
           line.find("INSTANCE") != std::string::npos ||
           line.find("FILE:LINE") != std::string::npos;
}

/**
 * @brief Split an assertion line into tokens
 * 
 * Splits an assertion data line into individual fields, handling
 * various whitespace and formatting issues.
 * 
 * Assertion lines can have complex formats with file paths, instance paths,
 * and assertion names that may contain special characters.
 * 
 * @param line Line to split
 * @return Vector of tokens
 */
std::vector<std::string> AssertParser::split_assert_line(const std::string& line) const {
    std::vector<std::string> tokens;
    std::istringstream iss(line);
    std::string token;
    
    // Simple whitespace-based splitting
    while (iss >> token) {
        tokens.push_back(token);
    }
    
    return tokens;
}

} // namespace coverage_parser