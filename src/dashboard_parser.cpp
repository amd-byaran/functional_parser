/**
 * @file dashboard_parser.cpp
 * @brief Implementation of the Dashboard parser for coverage analysis
 * 
 * This file contains the implementation of the DashboardParser class which
 * parses dashboard.txt files generated by URG (Unified Report Generator).
 * These files contain high-level coverage summary information including:
 * - Overall coverage metrics (ASSERT, GROUP scores)
 * - Tool and user information
 * - Command line used for generation
 * - Hierarchical instance counts
 * 
 * OUTPUT DATA STRUCTURE:
 * The parser populates a DashboardData object with the following structure:
 * {
 *   date: "Mon Sep  8 14:06:30 2025"       // Report generation date
 *   user: "byaran"                         // User who generated report
 *   version: "U-2023.03-SP2-9"            // Tool version information
 *   command_line: "urg -full64 -hvp..."   // Full command line used
 *   total_score: 31.56                    // Overall coverage percentage
 *   assert_coverage: {                    // Assertion coverage metrics
 *     covered: 60148,
 *     expected: 272087,
 *     score: 22.11,
 *     is_valid: true
 *   },
 *   group_coverage: {                     // Group coverage metrics
 *     covered: 134908,
 *     expected: 328987,
 *     score: 41.01,
 *     is_valid: true
 *   },
 *   num_hierarchical_instances: 1523      // Total hierarchy instances processed
 * }
 * 
 * PARSING ALGORITHM:
 * 1. Parse header section for metadata (date, user, version, command)
 * 2. Parse "Total Coverage Summary" section for overall metrics
 * 3. Parse "Hierarchical coverage data" section for instance information
 * 4. Store all data in DashboardData structure
 * 
 * EXAMPLE DASHBOARD FORMAT:
 * ```
 * Dashboard
 * 
 * Date: Mon Sep  8 14:06:30 2025
 * User: byaran
 * Version: U-2023.03-SP2-9
 * Command line: urg -full64 -hvp_no_score_missing ...
 * 
 * Total Coverage Summary 
 * SCORE   ASSERT               GROUP                
 *  31.56   22.11 60148/272087   41.01 134908/328987 
 * 
 * Hierarchical coverage data for top-level instances 
 * SCORE   ASSERT               NAME                                                                                                                                                            
 *   0.00    0.00 0/66          dcec_dc.dchubbubl.udchubbubl.uRET_PATH.udchubbub_ret_path_compbuf.udchubbub_ret_path_compbuf_metafifo.umetafifo_ram.mem_0_0.PDP
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Parse dashboard file
 * DashboardParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("dashboard.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     // Access parsed dashboard data
 *     auto dashboard = db.dashboard_data.get();
 *     if (dashboard && dashboard->is_valid()) {
 *         std::cout << "Total Coverage: " << dashboard->total_score << "%" << std::endl;
 *         std::cout << "Tool: " << dashboard->version << std::endl;
 *         std::cout << "Generated by: " << dashboard->user << std::endl;
 *         std::cout << "Command: " << dashboard->command_line << std::endl;
 *         
 *         // Check assertion coverage
 *         if (dashboard->assert_coverage.is_valid) {
 *             std::cout << "Assertions: " << dashboard->assert_coverage.covered 
 *                       << "/" << dashboard->assert_coverage.expected 
 *                       << " (" << dashboard->assert_coverage.score << "%)" << std::endl;
 *         }
 *         
 *         // Check group coverage  
 *         if (dashboard->group_coverage.is_valid) {
 *             std::cout << "Groups: " << dashboard->group_coverage.covered 
 *                       << "/" << dashboard->group_coverage.expected
 *                       << " (" << dashboard->group_coverage.score << "%)" << std::endl;
 *         }
 *         
 *         std::cout << "Hierarchical instances: " << dashboard->num_hierarchical_instances << std::endl;
 *     }
 * } else {
 *     std::cerr << "Failed to parse dashboard file" << std::endl;
 * }
 * ```
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 */

#include "functional_coverage_parser.h"
#include <sstream>
#include <regex>
#include <iomanip>
#include <algorithm>

namespace coverage_parser {

/**
 * @brief Parse a dashboard coverage file
 * 
 * Main entry point for parsing dashboard.txt files. Orchestrates the parsing
 * of different sections within the file.
 * 
 * @param filename Path to the dashboard file
 * @param db Database to populate with parsed data
 * @return ParserResult indicating success or failure
 */
ParserResult DashboardParser::parse(const std::string& filename, CoverageDatabase& db) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        return ParserResult::ERROR_FILE_NOT_FOUND;
    }
    
    // Create dashboard data structure
    auto dashboard_data = std::make_unique<DashboardData>();
    
    // Parse different sections of the file
    ParserResult result = parse_header_section(file, *dashboard_data);
    if (result != ParserResult::SUCCESS) {
        return result;
    }
    
    result = parse_coverage_summary(file, *dashboard_data);
    if (result != ParserResult::SUCCESS) {
        return result;
    }
    
    result = parse_hierarchical_instances(file, *dashboard_data);
    if (result != ParserResult::SUCCESS) {
        return result;
    }
    
    // Store parsed data in database
    db.dashboard_data = std::move(dashboard_data);
    db.is_valid = true;
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse the header section containing metadata
 * 
 * Parses the initial section of the dashboard file containing:
 * - Date of report generation
 * - User who generated the report
 * - Tool version information
 * - Full command line used
 * 
 * @param file Input file stream
 * @param dashboard Dashboard data structure to populate
 * @return ParserResult indicating success or failure
 */
ParserResult DashboardParser::parse_header_section(std::ifstream& file, DashboardData& dashboard) {
    std::string line;
    bool found_dashboard_title = false;
    
    // Look for "Dashboard" title
    while (std::getline(file, line)) {
        if (line.find("Dashboard") != std::string::npos && line.length() < 20) {
            found_dashboard_title = true;
            break;
        }
    }
    
    if (!found_dashboard_title) {
        return ParserResult::ERROR_INVALID_FORMAT;
    }
    
    // Parse metadata lines
    while (std::getline(file, line)) {
        // Skip empty lines
        if (line.empty()) {
            continue;
        }
        
        // Check if we've reached the coverage summary section
        if (line.find("Total Coverage Summary") != std::string::npos) {
            // Put this line back for the next parser
            file.seekg(-static_cast<long>(line.length() + 1), std::ios::cur);
            break;
        }
        
        // Parse specific metadata fields
        if (line.find("Date:") == 0) {
            dashboard.date = line.substr(5);
            // Trim whitespace
            dashboard.date.erase(0, dashboard.date.find_first_not_of(" \t"));
            dashboard.date.erase(dashboard.date.find_last_not_of(" \t") + 1);
            
            // Convert to time_point
            std::tm tm = {};
            std::istringstream ss(dashboard.date);
            ss >> std::get_time(&tm, "%a %b %d %H:%M:%S %Y");
            if (!ss.fail()) {
                dashboard.generation_time = std::chrono::system_clock::from_time_t(std::mktime(&tm));
            }
        }
        else if (line.find("User:") == 0) {
            dashboard.user = line.substr(5);
            dashboard.user.erase(0, dashboard.user.find_first_not_of(" \t"));
            dashboard.user.erase(dashboard.user.find_last_not_of(" \t") + 1);
        }
        else if (line.find("Version:") == 0) {
            dashboard.version = line.substr(8);
            dashboard.version.erase(0, dashboard.version.find_first_not_of(" \t"));
            dashboard.version.erase(dashboard.version.find_last_not_of(" \t") + 1);
        }
        else if (line.find("Command line:") == 0) {
            dashboard.command_line = line.substr(13);
            dashboard.command_line.erase(0, dashboard.command_line.find_first_not_of(" \t"));
            dashboard.command_line.erase(dashboard.command_line.find_last_not_of(" \t") + 1);
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse the coverage summary section
 * 
 * Parses the "Total Coverage Summary" section which contains overall
 * coverage metrics for ASSERT and GROUP coverage types.
 * 
 * Expected format:
 * ```
 * Total Coverage Summary 
 * SCORE   ASSERT               GROUP                
 *  31.56   22.11 60148/272087   41.01 134908/328987 
 * ```
 * 
 * @param file Input file stream
 * @param dashboard Dashboard data structure to populate
 * @return ParserResult indicating success or failure
 */
ParserResult DashboardParser::parse_coverage_summary(std::ifstream& file, DashboardData& dashboard) {
    std::string line;
    bool found_summary_section = false;
    
    // Look for coverage summary section
    while (std::getline(file, line)) {
        if (line.find("Total Coverage Summary") != std::string::npos) {
            found_summary_section = true;
            break;
        }
    }
    
    if (!found_summary_section) {
        return ParserResult::ERROR_INVALID_FORMAT;
    }
    
    // Skip header line with column names
    std::getline(file, line); // "SCORE   ASSERT               GROUP"
    
    // Parse the actual data line
    if (std::getline(file, line)) {
        std::istringstream iss(line);
        std::string token;
        std::vector<std::string> tokens;
        
        // Split by whitespace
        while (iss >> token) {
            tokens.push_back(token);
        }
        
        if (tokens.size() >= 4) {
            try {
                // Parse total score
                dashboard.total_score = std::stod(tokens[0]);
                
                // Parse ASSERT coverage: "22.11 60148/272087"
                dashboard.assert_coverage.score = std::stod(tokens[1]);
                
                // Parse assert coverage numbers from format "60148/272087"
                std::string assert_fraction = tokens[2];
                size_t slash_pos = assert_fraction.find('/');
                if (slash_pos != std::string::npos) {
                    dashboard.assert_coverage.covered = std::stoul(assert_fraction.substr(0, slash_pos));
                    dashboard.assert_coverage.expected = std::stoul(assert_fraction.substr(slash_pos + 1));
                    dashboard.assert_coverage.is_valid = true;
                }
                
                // Parse GROUP coverage: "41.01 134908/328987"
                dashboard.group_coverage.score = std::stod(tokens[3]);
                
                if (tokens.size() >= 5) {
                    std::string group_fraction = tokens[4];
                    slash_pos = group_fraction.find('/');
                    if (slash_pos != std::string::npos) {
                        dashboard.group_coverage.covered = std::stoul(group_fraction.substr(0, slash_pos));
                        dashboard.group_coverage.expected = std::stoul(group_fraction.substr(slash_pos + 1));
                        dashboard.group_coverage.is_valid = true;
                    }
                }
                
            } catch (const std::exception& e) {
                return ParserResult::ERROR_PARSE_FAILED;
            }
        }
    }
    
    return ParserResult::SUCCESS;
}

/**
 * @brief Parse the hierarchical instances section
 * 
 * Parses the "Hierarchical coverage data for top-level instances" section
 * to count the number of hierarchy instances and potentially extract
 * basic instance information.
 * 
 * @param file Input file stream
 * @param dashboard Dashboard data structure to populate
 * @return ParserResult indicating success or failure
 */
ParserResult DashboardParser::parse_hierarchical_instances(std::ifstream& file, DashboardData& dashboard) {
    std::string line;
    bool found_hierarchy_section = false;
    std::uint32_t instance_count = 0;
    
    // Look for hierarchical coverage section
    while (std::getline(file, line)) {
        if (line.find("Hierarchical coverage data") != std::string::npos) {
            found_hierarchy_section = true;
            break;
        }
    }
    
    if (!found_hierarchy_section) {
        // This section might not exist in all dashboard files
        dashboard.num_hierarchical_instances = 0;
        return ParserResult::SUCCESS;
    }
    
    // Skip header line
    std::getline(file, line); // "SCORE   ASSERT               NAME"
    
    // Count instances
    while (std::getline(file, line)) {
        // Skip empty lines
        if (line.empty()) {
            continue;
        }
        
        // Check if this looks like an instance line
        if (is_coverage_summary_line(line)) {
            instance_count++;
        }
        
        // Stop if we reach another section or end of file
        if (line.find("---") != std::string::npos || 
            line.find("Total") != std::string::npos) {
            break;
        }
    }
    
    dashboard.num_hierarchical_instances = instance_count;
    return ParserResult::SUCCESS;
}

/**
 * @brief Check if a line is a header line
 * 
 * Determines if the given line is a header/title line in the dashboard file.
 * 
 * @param line Line to check
 * @return true if line is a header, false otherwise
 */
bool DashboardParser::is_header_line(const std::string& line) const {
    return line.find("Dashboard") != std::string::npos ||
           line.find("Date:") != std::string::npos ||
           line.find("User:") != std::string::npos ||
           line.find("Version:") != std::string::npos ||
           line.find("Command line:") != std::string::npos ||
           line.find("Total Coverage Summary") != std::string::npos ||
           line.find("Hierarchical coverage data") != std::string::npos;
}

/**
 * @brief Check if a line contains coverage summary data
 * 
 * Determines if the given line contains numerical coverage data
 * (score, covered/expected ratios, instance paths).
 * 
 * @param line Line to check
 * @return true if line contains coverage data, false otherwise
 */
bool DashboardParser::is_coverage_summary_line(const std::string& line) const {
    // Look for pattern: number(s) followed by instance path
    std::regex coverage_pattern(R"(\s*\d+\.\d+\s+\d+\.\d+\s+\d+/\d+.*\w+)");
    return std::regex_match(line, coverage_pattern);
}

} // namespace coverage_parser