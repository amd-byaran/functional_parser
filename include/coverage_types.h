/**
 * @file coverage_types.h
 * @brief Comprehensive data types for Functional Coverage Parsers Library
 * 
 * This header defines all data structures used by the FunctionalCoverageParsers library
 * to represent different types of coverage reports from EDA tools (DVE/VCS/URG).
 * 
 * The library uses modern C++ containers (std::unordered_map, std::vector, std::string)
 * for efficient storage and retrieval of coverage data.
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 * 
 * USAGE EXAMPLE:
 * ```cpp
 * #include "coverage_types.h"
 * 
 * // Create a new coverage database
 * auto db = std::make_unique<coverage_parser::CoverageDatabase>();
 * 
 * // Parse files and populate database
 * coverage_parser::parse_dashboard_file("dashboard.txt", *db);
 * coverage_parser::parse_groups_file("groups.txt", *db);
 * 
 * // Access data
 * const auto& metrics = db->dashboard_data;
 * std::cout << "Total Score: " << metrics->total_score << std::endl;
 * ```
 */

#ifndef COVERAGE_TYPES_H
#define COVERAGE_TYPES_H

#include <string>
#include <unordered_map>
#include <vector>
#include <memory>
#include <chrono>

// Define integer types for Windows compatibility
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
#include <optional>
#include <iostream>
#include <fstream>

namespace coverage_parser {

/* Return codes for parser functions */
enum class ParserResult {
    SUCCESS = 0,
    ERROR_FILE_NOT_FOUND,
    ERROR_INVALID_FORMAT,
    ERROR_MEMORY_ALLOCATION,
    ERROR_INVALID_PARAMETER,
    ERROR_PARSE_FAILED
};

/**
 * @brief Coverage metrics structure containing hit/total counts and percentages
 * 
 * This structure represents basic coverage metrics with both absolute counts
 * and calculated percentages. Used throughout different coverage report types.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   covered: uint32     // Number of items that have been covered/exercised
 *   expected: uint32    // Total number of items that could be covered
 *   score: double       // Calculated coverage percentage (0.0 to 100.0)
 *   is_valid: bool      // Flag indicating if metrics data is valid
 * }
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Create metrics for line coverage (850 covered out of 1000 total)
 * CoverageMetrics line_cov(850, 1000);
 * std::cout << "Line Coverage: " << line_cov.score << "%" << std::endl;  // Outputs: 85.0%
 * 
 * // Check coverage quality
 * if (line_cov.score >= 90.0) {
 *     std::cout << "Excellent coverage!" << std::endl;
 * } else if (line_cov.score >= 70.0) {
 *     std::cout << "Good coverage" << std::endl;
 * }
 * 
 * // Manual creation and validation
 * CoverageMetrics toggle_cov;
 * toggle_cov.covered = 234;
 * toggle_cov.expected = 300;
 * toggle_cov.calculate_score();  // Calculates and sets score to 78.0%
 * 
 * // Check status
 * if (toggle_cov.is_fully_covered()) {
 *     std::cout << "100% coverage achieved!" << std::endl;
 * }
 * if (toggle_cov.has_no_coverage()) {
 *     std::cout << "No coverage detected!" << std::endl;
 * }
 * 
 * // Get coverage ratio (0.0 to 1.0)
 * double ratio = toggle_cov.coverage_ratio();  // Returns 0.78
 * ```
 */
class CoverageMetrics {
public:
    std::uint32_t covered{0};           /**< Number of covered items */
    std::uint32_t expected{0};          /**< Total number of expected items */
    double        score{0.0};           /**< Coverage percentage (0.0 - 100.0) */
    bool          is_valid{false};      /**< Flag indicating if metrics are valid */
    
    // Constructors
    CoverageMetrics() = default;
    CoverageMetrics(std::uint32_t cov, std::uint32_t exp) 
        : covered(cov), expected(exp), is_valid(true) {
        calculate_score();
    }
    
    // Calculate coverage percentage
    void calculate_score() {
        score = expected > 0 ? (static_cast<double>(covered) / expected) * 100.0 : 0.0;
        is_valid = true;
    }
    
    // Utility methods
    bool is_fully_covered() const { return covered == expected && expected > 0; }
    bool has_no_coverage() const { return covered == 0; }
    double coverage_ratio() const { return expected > 0 ? static_cast<double>(covered) / expected : 0.0; }
};

/**
 * @brief Dashboard coverage summary data
 * 
 * Contains high-level coverage summary information typically found in
 * dashboard.txt files generated by URG tool.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   date: string                    // Report generation date ("Mon Jan 15 14:30:25 2024")
 *   user: string                    // User who generated the report
 *   version: string                 // Tool version information
 *   command_line: string            // Full command line used to generate report
 *   total_score: double             // Overall coverage score (0.0 to 100.0)
 *   assert_coverage: CoverageMetrics // Assertion coverage summary
 *   group_coverage: CoverageMetrics  // Coverage group summary
 *   num_hierarchical_instances: uint32 // Total hierarchy instances processed
 *   generation_time: time_point     // Parsed timestamp from report
 * }
 * 
 * EXAMPLE DATA FORMAT:
 * ```
 * Total Coverage Summary 
 * SCORE   ASSERT               GROUP                
 *  31.56   22.11 60148/272087   41.01 134908/328987
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Access dashboard data from parsed database
 * auto dashboard = db->dashboard_data.get();
 * if (dashboard && dashboard->is_valid()) {
 *     std::cout << "Report Date: " << dashboard->date << std::endl;
 *     std::cout << "Total Coverage: " << dashboard->total_score << "%" << std::endl;
 *     std::cout << "Tool: " << dashboard->version << std::endl;
 *     
 *     // Check assertion coverage
 *     if (dashboard->assert_coverage.is_valid) {
 *         std::cout << "Assertions: " << dashboard->assert_coverage.covered 
 *                   << "/" << dashboard->assert_coverage.expected
 *                   << " (" << dashboard->assert_coverage.score << "%)" << std::endl;
 *     }
 *     
 *     // Check group coverage
 *     if (dashboard->group_coverage.is_valid) {
 *         std::cout << "Groups: " << dashboard->group_coverage.covered 
 *                   << "/" << dashboard->group_coverage.expected
 *                   << " (" << dashboard->group_coverage.score << "%)" << std::endl;
 *     }
 * }
 * 
 * // Get formatted date string
 * std::string formatted_date = dashboard->get_formatted_date();
 * std::cout << "Generated on: " << formatted_date << std::endl;
 * ```
 */
class DashboardData {
public:
    std::string                               date;                     /**< Report generation date */
    std::string                               user;                     /**< User who generated report */
    std::string                               version;                  /**< Tool version */
    std::string                               command_line;             /**< Full command line used */
    
    double                                    total_score{0.0};         /**< Overall coverage score */
    CoverageMetrics                          assert_coverage;          /**< Assertion coverage metrics */
    CoverageMetrics                          group_coverage;           /**< Group coverage metrics */
    
    std::uint32_t                            num_hierarchical_instances{0}; /**< Number of hierarchy instances */
    std::chrono::system_clock::time_point    generation_time;          /**< Parsed generation time */
    
    // Constructor
    DashboardData() = default;
    
    // Utility methods
    bool is_valid() const { return !date.empty() && !user.empty(); }
    std::string get_formatted_date() const;
};

/**
 * @brief Individual coverage group information
 * 
 * Represents a single coverage group entry from groups.txt files.
 * Each group has coverage metrics, weight, goals, and configuration.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   name: string                     // Full hierarchical group name
 *   comment: string                  // Optional comment/description
 *   coverage: CoverageMetrics        // Basic coverage metrics (covered/expected/score)
 *   instance_coverage: CoverageMetrics // Per-instance coverage metrics
 *   instances: uint32                // Number of instances of this group
 *   weight: uint32                   // Coverage weight (default: 1)
 *   goal: uint32                     // Coverage goal percentage (default: 100)
 *   at_least: uint32                 // Minimum required hits (default: 1)
 *   per_instance: uint32             // Per-instance requirement
 *   auto_bin_max: uint32             // Automatic bin maximum (default: 64)
 *   print_missing: uint32            // Print missing coverage flag
 *   is_auto_generated: bool          // True if auto-generated group
 * }
 * 
 * EXAMPLE DATA FORMAT:
 * ```
 * COVERED EXPECTED SCORE  INSTANCES WEIGHT GOAL   AT LEAST PER INSTANCE AUTO BIN MAX PRINT MISSING COMMENT NAME
 * 0       16         0.00   0.00    1      100    1        1            64           64                    tb.dco_rsmu_master_if::axi_wr_interchannels_cov
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Access specific coverage group
 * std::string group_name = "tb.cpu.alu::arithmetic_ops";
 * auto group = db->find_coverage_group(group_name);
 * if (group) {
 *     std::cout << "Group: " << group->name << std::endl;
 *     std::cout << "Coverage: " << group->coverage.score << "%" << std::endl;
 *     std::cout << "Hits: " << group->coverage.covered << "/" << group->coverage.expected << std::endl;
 *     
 *     // Check if group meets its goal
 *     if (group->meets_goal()) {
 *         std::cout << "✓ Goal achieved!" << std::endl;
 *     } else {
 *         std::cout << "✗ Goal not met (target: " << group->goal << "%)" << std::endl;
 *     }
 *     
 *     // Get weighted score
 *     double weighted = group->weighted_score();
 *     std::cout << "Weighted score: " << weighted << std::endl;
 *     
 *     // Check for empty groups
 *     if (group->is_empty()) {
 *         std::cout << "Warning: Empty group (no coverage points)" << std::endl;
 *     }
 * }
 * 
 * // Iterate through all groups
 * for (auto it = db->groups_begin(); it != db->groups_end(); ++it) {
 *     const auto& group = it->second;
 *     std::cout << group->name << ": " << group->coverage.score << "%" << std::endl;
 * }
 * 
 * // Find uncovered groups
 * auto uncovered = db->get_uncovered_groups();
 * std::cout << "Found " << uncovered.size() << " uncovered groups" << std::endl;
 * for (const auto* group : uncovered) {
 *     std::cout << "  " << group->name << std::endl;
 * }
 * ```
 */
class CoverageGroup {
public:
    std::string                               name;                     /**< Full hierarchical group name */
    std::string                               comment;                  /**< Optional comment/description */
    
    CoverageMetrics                          coverage;                 /**< Basic coverage metrics */
    CoverageMetrics                          instance_coverage;        /**< Per-instance coverage */
    
    std::uint32_t                            instances{0};             /**< Number of instances */
    std::uint32_t                            weight{1};                /**< Coverage weight */
    std::uint32_t                            goal{100};                /**< Coverage goal percentage */
    std::uint32_t                            at_least{1};              /**< Minimum required hits */
    std::uint32_t                            per_instance{0};          /**< Per-instance requirement */
    std::uint32_t                            auto_bin_max{64};         /**< Automatic bin maximum */
    std::uint32_t                            print_missing{64};        /**< Print missing coverage flag */
    
    bool                                     is_auto_generated{false}; /**< Auto-generated group flag */
    
    // Constructors
    CoverageGroup() = default;
    explicit CoverageGroup(const std::string& group_name) : name(group_name) {}
    
    // Utility methods
    bool meets_goal() const { return coverage.score >= goal; }
    bool is_empty() const { return coverage.expected == 0; }
    std::string get_hierarchy_level() const;
    double weighted_score() const { return coverage.score * weight / 100.0; }
};

/**
 * @brief Hierarchical design instance coverage
 * 
 * Represents coverage data for individual design hierarchy instances
 * from hierarchy.txt files.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   instance_path: string           // Full hierarchical path ("top.cpu.alu")
 *   module_name: string             // Module/block name ("alu")
 *   total_score: double             // Instance total coverage score
 *   assert_coverage: CoverageMetrics // Assertion coverage for this instance
 *   group_coverage: CoverageMetrics  // Group coverage for this instance
 *   depth_level: uint32             // Hierarchy depth (0=top, 1=level1, etc.)
 *   is_leaf_instance: bool          // True if this is a leaf node
 * }
 * 
 * EXAMPLE DATA FORMAT:
 * ```
 * SCORE   ASSERT          
 *   0.00    0.00 0/66   dcec_dc.dchubbubl.udchubbubl.uRET_PATH.mem_0_0.PDP
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Access specific hierarchy instance
 * std::string instance_path = "top.cpu.alu";
 * auto instance = db->find_hierarchy_instance(instance_path);
 * if (instance) {
 *     std::cout << "Instance: " << instance->instance_path << std::endl;
 *     std::cout << "Module: " << instance->module_name << std::endl;
 *     std::cout << "Depth: " << instance->depth_level << std::endl;
 *     std::cout << "Score: " << instance->total_score << "%" << std::endl;
 *     
 *     // Check assertion coverage
 *     if (instance->assert_coverage.is_valid) {
 *         std::cout << "Assertions: " << instance->assert_coverage.covered 
 *                   << "/" << instance->assert_coverage.expected << std::endl;
 *     }
 *     
 *     // Get parent instance path
 *     std::string parent = instance->get_parent_path();
 *     if (!parent.empty()) {
 *         std::cout << "Parent: " << parent << std::endl;
 *     }
 *     
 *     // Get path components
 *     auto components = instance->get_path_components();
 *     std::cout << "Path components: ";
 *     for (size_t i = 0; i < components.size(); ++i) {
 *         if (i > 0) std::cout << " -> ";
 *         std::cout << components[i];
 *     }
 *     std::cout << std::endl;
 *     
 *     // Check if leaf instance
 *     if (instance->is_leaf_instance) {
 *         std::cout << "This is a leaf instance" << std::endl;
 *     }
 * }
 * 
 * // Iterate through hierarchy instances by depth
 * std::map<uint32_t, std::vector<HierarchyInstance*>> by_depth;
 * for (auto it = db->hierarchy_begin(); it != db->hierarchy_end(); ++it) {
 *     auto* instance = it->second.get();
 *     by_depth[instance->depth_level].push_back(instance);
 * }
 * 
 * // Print hierarchy by depth
 * for (const auto& [depth, instances] : by_depth) {
 *     std::cout << "Depth " << depth << ":" << std::endl;
 *     for (const auto* instance : instances) {
 *         std::string indent(depth * 2, ' ');
 *         std::cout << indent << instance->instance_path 
 *                   << " (" << instance->total_score << "%)" << std::endl;
 *     }
 * }
 * ```
 */
class HierarchyInstance {
public:
    std::string                               instance_path;            /**< Full hierarchical path */
    std::string                               module_name;              /**< Module/block name */
    
    double                                    total_score{0.0};         /**< Instance total score */
    CoverageMetrics                          assert_coverage;          /**< Assertion coverage */
    CoverageMetrics                          group_coverage;           /**< Group coverage (if available) */
    
    std::uint32_t                            depth_level{0};           /**< Hierarchy depth */
    bool                                     is_leaf_instance{false};  /**< True if leaf node */
    
    // Constructors
    HierarchyInstance() = default;
    explicit HierarchyInstance(const std::string& path) : instance_path(path) {
        calculate_depth_level();
        extract_module_name();
    }
    
    // Utility methods
    void calculate_depth_level();
    void extract_module_name();
    std::string get_parent_path() const;
    std::vector<std::string> get_path_components() const;
};

/**
 * @brief Module definition coverage information
 * 
 * Contains coverage data for module definitions from modlist.txt files.
 * Tracks coverage across all instances of a module type.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   module_name: string             // Module definition name
 *   total_score: double             // Module total coverage score
 *   assert_coverage: CoverageMetrics // Assertion coverage for this module
 *   group_coverage: CoverageMetrics  // Group coverage for this module
 *   instance_count: uint32          // Number of instances of this module
 *   covered_instances: uint32       // Number of instances with coverage
 * }
 * 
 * EXAMPLE DATA FORMAT:
 * ```
 * SCORE   ASSERT          NAME                                                   
 *   0.00    0.00 0/1      az_memory_allocation_disallocation_collision
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Access specific module definition
 * std::string module_name = "cpu_core";
 * auto module = db->find_module_definition(module_name);
 * if (module) {
 *     std::cout << "Module: " << module->module_name << std::endl;
 *     std::cout << "Total Score: " << module->total_score << "%" << std::endl;
 *     std::cout << "Instances: " << module->instance_count << std::endl;
 *     std::cout << "Covered Instances: " << module->covered_instances << std::endl;
 *     
 *     // Check assertion coverage
 *     if (module->assert_coverage.is_valid) {
 *         std::cout << "Assertions: " << module->assert_coverage.covered 
 *                   << "/" << module->assert_coverage.expected 
 *                   << " (" << module->assert_coverage.score << "%)" << std::endl;
 *     }
 *     
 *     // Get instance coverage percentage
 *     double instance_coverage = module->instance_coverage_percentage();
 *     std::cout << "Instance Coverage: " << instance_coverage << "%" << std::endl;
 *     
 *     // Check if fully covered
 *     if (module->is_fully_covered()) {
 *         std::cout << "✓ All instances covered!" << std::endl;
 *     } else {
 *         uint32_t uncovered = module->instance_count - module->covered_instances;
 *         std::cout << "✗ " << uncovered << " instances not covered" << std::endl;
 *     }
 * }
 * 
 * // Find modules with low coverage
 * std::vector<ModuleDefinition*> low_coverage_modules;
 * for (auto it = db->modules_table.begin(); it != db->modules_table.end(); ++it) {
 *     auto* module = it->second.get();
 *     if (module->total_score < 50.0) {
 *         low_coverage_modules.push_back(module);
 *     }
 * }
 * 
 * std::cout << "Modules with low coverage:" << std::endl;
 * for (const auto* module : low_coverage_modules) {
 *     std::cout << "  " << module->module_name 
 *               << ": " << module->total_score << "%" << std::endl;
 * }
 * 
 * // Sort modules by coverage score
 * std::vector<std::pair<std::string, double>> module_scores;
 * for (const auto& [name, module] : db->modules_table) {
 *     module_scores.emplace_back(module->module_name, module->total_score);
 * }
 * std::sort(module_scores.begin(), module_scores.end(), 
 *          [](const auto& a, const auto& b) { return a.second > b.second; });
 * 
 * std::cout << "Top modules by coverage:" << std::endl;
 * for (size_t i = 0; i < std::min(size_t(10), module_scores.size()); ++i) {
 *     std::cout << (i+1) << ". " << module_scores[i].first 
 *               << ": " << module_scores[i].second << "%" << std::endl;
 * }
 * ```
 */
class ModuleDefinition {
public:
    std::string                               module_name;              /**< Module definition name */
    
    double                                    total_score{0.0};         /**< Module total score */
    CoverageMetrics                          assert_coverage;          /**< Assertion coverage */
    CoverageMetrics                          group_coverage;           /**< Group coverage (if available) */
    
    std::uint32_t                            instance_count{0};        /**< Number of instances */
    std::uint32_t                            covered_instances{0};     /**< Number of covered instances */
    
    // Constructors
    ModuleDefinition() = default;
    explicit ModuleDefinition(const std::string& name) : module_name(name) {}
    
    // Utility methods
    double instance_coverage_percentage() const {
        return instance_count > 0 ? 
               (static_cast<double>(covered_instances) / instance_count) * 100.0 : 0.0;
    }
    bool is_fully_covered() const { return covered_instances == instance_count && instance_count > 0; }
};

/**
 * @brief Assert coverage information
 * 
 * Individual assertion coverage data from asserts.txt files.
 * Contains detailed information about each assertion.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   assert_name: string             // Assertion name/identifier
 *   instance_path: string           // Instance where assertion exists
 *   file_location: string           // Source file location
 *   line_number: uint32             // Line number in source file
 *   is_covered: bool                // Coverage status (true if hit)
 *   hit_count: uint32               // Number of times assertion was hit
 *   severity: string                // Assertion severity level ("PASS", "FAIL", etc.)
 *   message: string                 // Assertion message/description
 * }
 * 
 * EXAMPLE DATA FORMAT:
 * ```
 * STATUS  HITS    ASSERTION                   INSTANCE            FILE:LINE
 * PASS    1234    check_valid_transaction     tb.cpu.alu          alu.sv:45
 * FAIL    0       check_data_integrity        tb.mem.ctrl         mem_ctrl.sv:123
 * ```
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Access specific assertion
 * std::string assert_name = "check_valid_transaction";
 * auto assertion = db->find_assert_coverage(assert_name);
 * if (assertion) {
 *     std::cout << "Assertion: " << assertion->assert_name << std::endl;
 *     std::cout << "Location: " << assertion->get_full_location() << std::endl;
 *     std::cout << "Instance: " << assertion->instance_path << std::endl;
 *     std::cout << "Status: " << (assertion->is_covered ? "COVERED" : "NOT COVERED") << std::endl;
 *     std::cout << "Hit Count: " << assertion->hit_count << std::endl;
 *     std::cout << "Severity: " << assertion->severity << std::endl;
 *     
 *     // Check if critical assertion
 *     if (assertion->is_critical()) {
 *         std::cout << "⚠️  CRITICAL assertion!" << std::endl;
 *     }
 * }
 * 
 * // Find uncovered assertions
 * std::vector<AssertCoverage*> uncovered_assertions;
 * for (auto& [name, assert_cov] : db->asserts_table) {
 *     if (!assert_cov->is_covered) {
 *         uncovered_assertions.push_back(assert_cov.get());
 *     }
 * }
 * 
 * std::cout << "Uncovered assertions (" << uncovered_assertions.size() << "):" << std::endl;
 * for (const auto* assertion : uncovered_assertions) {
 *     std::cout << "  ✗ " << assertion->assert_name 
 *               << " at " << assertion->get_full_location() << std::endl;
 * }
 * 
 * // Find critical failed assertions
 * std::vector<AssertCoverage*> critical_failures;
 * for (auto& [name, assert_cov] : db->asserts_table) {
 *     if (!assert_cov->is_covered && assert_cov->is_critical()) {
 *         critical_failures.push_back(assert_cov.get());
 *     }
 * }
 * 
 * if (!critical_failures.empty()) {
 *     std::cout << "🚨 CRITICAL FAILURES (" << critical_failures.size() << "):" << std::endl;
 *     for (const auto* assertion : critical_failures) {
 *         std::cout << "  🔥 " << assertion->assert_name 
 *                   << " in " << assertion->instance_path << std::endl;
 *     }
 * }
 * 
 * // Generate assertion statistics
 * uint32_t total_assertions = db->get_num_asserts();
 * uint32_t covered_assertions = 0;
 * uint32_t total_hits = 0;
 * 
 * for (const auto& [name, assert_cov] : db->asserts_table) {
 *     if (assert_cov->is_covered) {
 *         covered_assertions++;
 *     }
 *     total_hits += assert_cov->hit_count;
 * }
 * 
 * double assertion_coverage = (100.0 * covered_assertions) / total_assertions;
 * std::cout << "Assertion Coverage: " << assertion_coverage << "%" << std::endl;
 * std::cout << "Total Hits: " << total_hits << std::endl;
 * ```
 */
class AssertCoverage {
public:
    std::string                               assert_name;              /**< Assertion name/identifier */
    std::string                               instance_path;            /**< Instance where assert exists */
    std::string                               file_location;            /**< Source file location */
    
    std::uint32_t                            line_number{0};           /**< Line number in source */
    bool                                     is_covered{false};        /**< Coverage status */
    std::uint32_t                            hit_count{0};             /**< Number of times hit */
    
    std::string                               severity;                 /**< Assertion severity level */
    std::string                               message;                  /**< Assertion message */
    
    // Constructors
    AssertCoverage() = default;
    explicit AssertCoverage(const std::string& name) : assert_name(name) {}
    
    // Utility methods
    bool is_critical() const { return severity == "ERROR" || severity == "FATAL"; }
    std::string get_full_location() const { return file_location + ":" + std::to_string(line_number); }
};

/**
 * @brief Statistics and analysis results
 * 
 * Contains computed statistics and analysis results from the coverage database.
 * Used for generating reports and summaries.
 */
class CoverageStatistics {
public:
    // Overall statistics
    double                                    overall_coverage_score{0.0};     /**< Weighted overall score */
    std::uint32_t                            total_coverage_points{0};        /**< Total coverage points */
    std::uint32_t                            covered_points{0};               /**< Covered points */
    
    // Per-type statistics
    CoverageMetrics                          group_stats;                     /**< Group coverage statistics */
    CoverageMetrics                          hierarchy_stats;                 /**< Hierarchy coverage statistics */
    CoverageMetrics                          module_stats;                    /**< Module coverage statistics */
    CoverageMetrics                          assert_stats;                    /**< Assert coverage statistics */
    
    // Top uncovered items
    std::vector<std::string>                 top_uncovered_groups;            /**< Top uncovered groups */
    std::vector<std::string>                 top_uncovered_modules;           /**< Top uncovered modules */
    
    std::uint32_t                            num_zero_coverage_groups{0};     /**< Groups with 0% coverage */
    std::uint32_t                            num_full_coverage_groups{0};     /**< Groups with 100% coverage */
    
    std::chrono::system_clock::time_point    analysis_time;                   /**< When analysis was performed */
    
    // Constructor
    CoverageStatistics() = default;
    
    // Utility methods
    void calculate_overall_score();
    std::vector<std::pair<std::string, double>> get_coverage_distribution() const;
};

/**
 * @brief Parser configuration and options
 * 
 * Configuration structure for customizing parser behavior.
 */
class ParserConfig {
public:
    bool                                     ignore_empty_groups{false};      /**< Skip groups with no coverage */
    bool                                     parse_comments{true};            /**< Parse comment fields */
    bool                                     validate_hierarchy{true};        /**< Validate hierarchy paths */
    std::uint32_t                            max_groups{0};                   /**< Maximum groups to parse (0=unlimited) */
    std::uint32_t                            max_instances{0};                /**< Maximum instances to parse (0=unlimited) */
    double                                   min_coverage_threshold{0.0};     /**< Minimum coverage to include */
    
    std::string                              base_path;                       /**< Base path for relative paths */
    
    // Constructor
    ParserConfig() = default;
    
    // Static factory methods
    static ParserConfig create_default();
    static ParserConfig create_fast_parsing();
    static ParserConfig create_detailed_parsing();
};

/**
 * @brief Master coverage database structure
 * 
 * Main container that holds all parsed coverage data from different report files.
 * Uses hash maps for efficient storage and retrieval of coverage information.
 * 
 * OUTPUT DATA STRUCTURE:
 * {
 *   dashboard_data: unique_ptr<DashboardData>           // Overall coverage summary
 *   groups_table: map<string, unique_ptr<CoverageGroup>> // Hash table of coverage groups
 *   hierarchy_table: map<string, unique_ptr<HierarchyInstance>> // Hash table of hierarchy instances
 *   modules_table: map<string, unique_ptr<ModuleDefinition>>    // Hash table of module definitions
 *   asserts_table: map<string, unique_ptr<AssertCoverage>>      // Hash table of assertions
 *   last_updated: time_point                            // Last update timestamp
 *   is_valid: bool                                      // Database validity flag
 * }
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Create and populate database
 * auto db = std::make_unique<CoverageDatabase>();
 * 
 * // Parse all coverage files
 * DashboardParser dashboard_parser;
 * GroupsParser groups_parser;
 * HierarchyParser hierarchy_parser;
 * ModuleListParser modules_parser;
 * AssertParser assert_parser;
 * 
 * dashboard_parser.parse("dashboard.txt", *db);
 * groups_parser.parse("groups.txt", *db);
 * hierarchy_parser.parse("hierarchy.txt", *db);
 * modules_parser.parse("modlist.txt", *db);
 * assert_parser.parse("asserts.txt", *db);
 * 
 * // Validate database
 * if (db->validate()) {
 *     std::cout << "Database is valid and ready for analysis" << std::endl;
 * }
 * 
 * // Query summary statistics
 * std::cout << "Database Summary:" << std::endl;
 * std::cout << "  Coverage Groups: " << db->get_num_groups() << std::endl;
 * std::cout << "  Hierarchy Instances: " << db->get_num_hierarchy_instances() << std::endl;
 * std::cout << "  Module Definitions: " << db->get_num_modules() << std::endl;
 * std::cout << "  Assertions: " << db->get_num_asserts() << std::endl;
 * 
 * // Calculate overall score
 * double overall_score = db->calculate_overall_score();
 * std::cout << "Overall Coverage Score: " << overall_score << "%" << std::endl;
 * 
 * // Access dashboard summary
 * if (db->dashboard_data && db->dashboard_data->is_valid()) {
 *     const auto& dashboard = db->dashboard_data;
 *     std::cout << "Report Date: " << dashboard->date << std::endl;
 *     std::cout << "Tool Version: " << dashboard->version << std::endl;
 *     std::cout << "Total Score: " << dashboard->total_score << "%" << std::endl;
 * }
 * 
 * // Find specific coverage group
 * std::string group_name = "tb.cpu.alu::arithmetic_ops";
 * auto group = db->find_coverage_group(group_name);
 * if (group) {
 *     std::cout << "Found group: " << group->name 
 *               << " (" << group->coverage.score << "%)" << std::endl;
 * }
 * 
 * // Search for groups by pattern (contains substring)
 * auto matching_groups = db->get_groups_by_pattern("cpu");
 * std::cout << "Groups matching 'cpu':" << std::endl;
 * for (const auto* group : matching_groups) {
 *     std::cout << "  " << group->name << ": " << group->coverage.score << "%" << std::endl;
 * }
 * 
 * // Find uncovered groups
 * auto uncovered = db->get_uncovered_groups();
 * std::cout << "Uncovered groups (" << uncovered.size() << "):" << std::endl;
 * for (const auto* group : uncovered) {
 *     std::cout << "  ✗ " << group->name << std::endl;
 * }
 * 
 * // Range-based iteration over groups
 * for (const auto& [name, group] : db->groups_table) {
 *     if (group->coverage.score >= 90.0) {
 *         std::cout << "High coverage: " << group->name 
 *                   << " (" << group->coverage.score << "%)" << std::endl;
 *     }
 * }
 * 
 * // Generate detailed statistics
 * auto stats = db->generate_statistics();
 * if (stats) {
 *     std::cout << "Statistics:" << std::endl;
 *     std::cout << "  Overall Score: " << stats->overall_coverage_score << "%" << std::endl;
 *     std::cout << "  Total Points: " << stats->total_coverage_points << std::endl;
 *     std::cout << "  Covered Points: " << stats->covered_points << std::endl;
 *     std::cout << "  Zero Coverage Groups: " << stats->num_zero_coverage_groups << std::endl;
 *     std::cout << "  Full Coverage Groups: " << stats->num_full_coverage_groups << std::endl;
 * }
 * 
 * // Reset database for reuse
 * db->reset();
 * ```
 */
class CoverageDatabase {
public:
    // Dashboard summary data
    std::unique_ptr<DashboardData>                               dashboard_data;              /**< Overall coverage summary */
    
    // Hash tables for different coverage types
    std::unordered_map<std::string, std::unique_ptr<CoverageGroup>>      groups_table;           /**< Hash table of coverage groups */
    std::unordered_map<std::string, std::unique_ptr<HierarchyInstance>>  hierarchy_table;        /**< Hash table of hierarchy instances */
    std::unordered_map<std::string, std::unique_ptr<ModuleDefinition>>   modules_table;          /**< Hash table of module definitions */
    std::unordered_map<std::string, std::unique_ptr<AssertCoverage>>     asserts_table;          /**< Hash table of assertions */
    
    // Metadata
    std::chrono::system_clock::time_point                        last_updated;               /**< Last update timestamp */
    bool                                                         is_valid{false};            /**< Database validity flag */
    
    // Constructor
    CoverageDatabase();
    
    // Destructor
    ~CoverageDatabase() = default;
    
    // Delete copy constructor and assignment operator
    CoverageDatabase(const CoverageDatabase&) = delete;
    CoverageDatabase& operator=(const CoverageDatabase&) = delete;
    
    // Move constructor and assignment operator
    CoverageDatabase(CoverageDatabase&&) = default;
    CoverageDatabase& operator=(CoverageDatabase&&) = default;
    
    // Accessor methods
    std::uint32_t get_num_groups() const { return static_cast<std::uint32_t>(groups_table.size()); }
    std::uint32_t get_num_hierarchy_instances() const { return static_cast<std::uint32_t>(hierarchy_table.size()); }
    std::uint32_t get_num_modules() const { return static_cast<std::uint32_t>(modules_table.size()); }
    std::uint32_t get_num_asserts() const { return static_cast<std::uint32_t>(asserts_table.size()); }
    
    // Query methods
    CoverageGroup* find_coverage_group(const std::string& name);
    const CoverageGroup* find_coverage_group(const std::string& name) const;
    
    HierarchyInstance* find_hierarchy_instance(const std::string& path);
    const HierarchyInstance* find_hierarchy_instance(const std::string& path) const;
    
    ModuleDefinition* find_module_definition(const std::string& name);
    const ModuleDefinition* find_module_definition(const std::string& name) const;
    
    AssertCoverage* find_assert_coverage(const std::string& name);
    const AssertCoverage* find_assert_coverage(const std::string& name) const;
    
    // Data manipulation methods
    void add_coverage_group(std::unique_ptr<CoverageGroup> group);
    void add_hierarchy_instance(std::unique_ptr<HierarchyInstance> instance);
    void add_module_definition(std::unique_ptr<ModuleDefinition> module);
    void add_assert_coverage(std::unique_ptr<AssertCoverage> assert_cov);
    
    // Utility methods
    void reset();
    bool validate() const;
    double calculate_overall_score() const;
    std::vector<CoverageGroup*> get_groups_by_pattern(const std::string& pattern) const;
    std::vector<CoverageGroup*> get_uncovered_groups() const;
    std::unique_ptr<CoverageStatistics> generate_statistics() const;
    
    // Iterator support for range-based loops
    auto groups_begin() { return groups_table.begin(); }
    auto groups_end() { return groups_table.end(); }
    auto groups_begin() const { return groups_table.cbegin(); }
    auto groups_end() const { return groups_table.cend(); }
    
    auto hierarchy_begin() { return hierarchy_table.begin(); }
    auto hierarchy_end() { return hierarchy_table.end(); }
    auto hierarchy_begin() const { return hierarchy_table.cbegin(); }
    auto hierarchy_end() const { return hierarchy_table.cend(); }
    
private:
    void update_timestamp() { last_updated = std::chrono::system_clock::now(); }
};

// Utility functions
std::string parser_result_to_string(ParserResult result);
std::ostream& operator<<(std::ostream& os, const CoverageMetrics& metrics);
std::ostream& operator<<(std::ostream& os, const CoverageGroup& group);

} // namespace coverage_parser

#endif /* COVERAGE_TYPES_H */