/**
 * @file functional_coverage_parser.h
 * @brief Main API header for the Functional Coverage Parsers Library
 * 
 * This header provides the complete public API for parsing various functional
 * coverage report formats generated by EDA tools such as DVE, VCS, and URG.
 * 
 * The library uses a modular design with separate parsers for each file type:
 * - DashboardParser for dashboard.txt files
 * - GroupsParser for groups.txt files  
 * - HierarchyParser for hierarchy.txt files
 * - ModuleListParser for modlist.txt files
 * - AssertParser for asserts.txt files
 * 
 * @author FunctionalCoverageParsers Library
 * @version 1.0
 * @date 2025
 * 
 * LIBRARY USAGE EXAMPLE:
 * ```cpp
 * #include "functional_coverage_parser.h"
 * 
 * int main() {
 *     using namespace coverage_parser;
 * 
 *     // Create coverage database
 *     auto db = std::make_unique<CoverageDatabase>();
 * 
 *     // Create parsers
 *     DashboardParser dashboard_parser;
 *     GroupsParser groups_parser;
 *     HierarchyParser hierarchy_parser;
 *     ModuleListParser modlist_parser;
 * 
 *     // Parse coverage files
 *     auto result = dashboard_parser.parse("reports/dashboard.txt", *db);
 *     if (result != ParserResult::SUCCESS) {
 *         std::cerr << "Dashboard parse failed: " << get_error_string(result) << std::endl;
 *     }
 * 
 *     result = groups_parser.parse("reports/groups.txt", *db);
 *     if (result != ParserResult::SUCCESS) {
 *         std::cerr << "Groups parse failed: " << get_error_string(result) << std::endl;
 *     }
 * 
 *     // Query coverage data
 *     double overall_score = db->calculate_overall_score();
 *     std::cout << "Overall Coverage: " << overall_score << "%" << std::endl;
 * 
 *     // Find specific coverage group
 *     auto group = db->find_coverage_group("tb.cpu.alu::arithmetic_ops");
 *     if (group) {
 *         std::cout << "Group '" << group->name << "' coverage: " << group->coverage.score 
 *                   << "% (" << group->coverage.covered << "/" << group->coverage.expected << ")" << std::endl;
 *     }
 * 
 *     return 0;
 * }
 * ```
 */

#ifndef FUNCTIONAL_COVERAGE_PARSER_H
#define FUNCTIONAL_COVERAGE_PARSER_H

#include "coverage_types.h"
#include <iostream>
#include <fstream>
#include <string>
#include <memory>
#include <vector>
#include <chrono>

namespace coverage_parser {

/* Library version information */
constexpr int VERSION_MAJOR = 1;
constexpr int VERSION_MINOR = 0;
constexpr int VERSION_PATCH = 0;
constexpr const char* VERSION_STRING = "1.0.0";

/* Export macros for DLL building */
#ifdef _WIN32
    #ifdef BUILDING_COVERAGE_PARSER_DLL
        #define COVERAGE_PARSER_API __declspec(dllexport)
    #else
        #define COVERAGE_PARSER_API __declspec(dllimport)
    #endif
#else
    #define COVERAGE_PARSER_API
#endif

/**
 * @brief Base parser interface for all coverage file parsers
 * 
 * Abstract base class that defines the common interface for all
 * coverage file parsers. Each specific parser inherits from this class
 * and implements the parse() method for their specific file format.
 * 
 * DESIGN PATTERN:
 * This follows the Template Method pattern where the base class defines
 * the interface and common functionality, while derived classes implement
 * format-specific parsing logic.
 * 
 * OUTPUT DATA FLOW:
 * BaseParser -> parse(filename, db) -> ParserResult
 * 1. Validates input parameters
 * 2. Opens and reads the file
 * 3. Calls format-specific parsing logic
 * 4. Populates the CoverageDatabase with parsed data
 * 5. Returns success/failure status
 * 
 * USAGE EXAMPLES:
 * ```cpp
 * // Use specific parser directly
 * DashboardParser dashboard_parser;
 * ParserResult result = dashboard_parser.parse("dashboard.txt", db);
 * 
 * // Use polymorphically
 * std::unique_ptr<BaseParser> parser = std::make_unique<GroupsParser>();
 * result = parser->parse("groups.txt", db);
 * 
 * // Configure parser behavior
 * ParserConfig config;
 * config.ignore_empty_groups = true;
 * config.min_coverage_threshold = 10.0;
 * parser->set_config(config);
 * 
 * // Get parser information
 * std::cout << "Using: " << parser->get_parser_info() << std::endl;
 * ```
 * 
 * PARSER HIERARCHY:
 * BaseParser (abstract)
 * ├── DashboardParser    - Parses dashboard.txt (overall summaries)
 * ├── GroupsParser       - Parses groups.txt (coverage groups)
 * ├── HierarchyParser    - Parses hierarchy.txt (design hierarchy)
 * ├── ModuleListParser   - Parses modlist.txt (module definitions)
 * └── AssertParser       - Parses asserts.txt (assertion coverage)
 */
class COVERAGE_PARSER_API BaseParser {
public:
    virtual ~BaseParser() = default;
    
    /**
     * @brief Parse a coverage file and populate the database
     * @param filename Path to the coverage file
     * @param db Database to populate with parsed data
     * @return ParserResult indicating success or failure
     */
    virtual ParserResult parse(const std::string& filename, CoverageDatabase& db) = 0;
    
    /**
     * @brief Set parser configuration
     * @param config Configuration options for parsing
     */
    virtual void set_config(const ParserConfig& config) { config_ = config; }
    
    /**
     * @brief Get current parser configuration
     * @return Current configuration
     */
    virtual const ParserConfig& get_config() const { return config_; }
    
    /**
     * @brief Get parser-specific information
     * @return String describing the parser type
     */
    virtual std::string get_parser_info() const = 0;

protected:
    ParserConfig config_;
};

/**
 * @brief Dashboard parser for dashboard.txt files
 * 
 * Parses dashboard coverage files containing overall coverage summary,
 * tool information, and high-level metrics.
 * 
 * OUTPUT DATA STRUCTURE:
 * Creates a DashboardData object containing:
 * - date: Report generation timestamp
 * - user: User who generated the report
 * - version: Tool version information
 * - command_line: Full command used to generate report
 * - total_score: Overall coverage percentage
 * - assert_coverage: Assertion coverage summary metrics
 * - group_coverage: Coverage group summary metrics
 * - num_hierarchical_instances: Count of hierarchy instances
 * 
 * SUPPORTED FILE FORMATS:
 * - URG (Unified Report Generator) dashboard.txt
 * - VCS dashboard reports
 * - DVE summary reports
 * 
 * EXAMPLE USAGE:
 * ```cpp
 * DashboardParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("dashboard.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     auto dashboard = db.dashboard_data.get();
 *     if (dashboard) {
 *         std::cout << "Total Coverage: " << dashboard->total_score << "%" << std::endl;
 *         std::cout << "Generated by: " << dashboard->version << std::endl;
 *         std::cout << "User: " << dashboard->user << std::endl;
 *         std::cout << "Command: " << dashboard->command_line << std::endl;
 *     }
 * }
 * ```
 */
class COVERAGE_PARSER_API DashboardParser : public BaseParser {
public:
    DashboardParser() = default;
    ~DashboardParser() override = default;
    
    ParserResult parse(const std::string& filename, CoverageDatabase& db) override;
    std::string get_parser_info() const override { return "Dashboard Parser v1.0"; }
    
private:
    ParserResult parse_header_section(std::ifstream& file, DashboardData& dashboard);
    ParserResult parse_coverage_summary(std::ifstream& file, DashboardData& dashboard);
    ParserResult parse_hierarchical_instances(std::ifstream& file, DashboardData& dashboard);
    bool is_header_line(const std::string& line) const;
    bool is_coverage_summary_line(const std::string& line) const;
};

/**
 * @brief Groups parser for groups.txt files
 * 
 * Parses groups coverage files containing testbench coverage group
 * information with detailed metrics for each group.
 * 
 * OUTPUT DATA STRUCTURE:
 * Creates CoverageGroup objects for each group containing:
 * - name: Full hierarchical group name
 * - coverage: Basic coverage metrics (covered/expected/score)
 * - instance_coverage: Per-instance coverage metrics
 * - instances: Number of instances of this group
 * - weight: Coverage weight for scoring
 * - goal: Coverage goal percentage
 * - at_least: Minimum required hits
 * - auto_bin_max: Automatic bin maximum
 * - comment: Optional group description
 * 
 * SUPPORTED FILE FORMATS:
 * - URG groups.txt files
 * - VCS coverage group reports
 * - SystemVerilog covergroup summaries
 * 
 * EXAMPLE USAGE:
 * ```cpp
 * GroupsParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("groups.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     std::cout << "Parsed " << db.get_num_groups() << " coverage groups" << std::endl;
 *     
 *     // Find specific group
 *     auto group = db.find_coverage_group("tb.cpu.alu::arithmetic_ops");
 *     if (group) {
 *         std::cout << "Group: " << group->name << std::endl;
 *         std::cout << "Coverage: " << group->coverage.score << "%" << std::endl;
 *         std::cout << "Weight: " << group->weight << std::endl;
 *         std::cout << "Goal: " << group->goal << "%" << std::endl;
 *         
 *         if (group->meets_goal()) {
 *             std::cout << "✓ Goal achieved!" << std::endl;
 *         }
 *     }
 *     
 *     // Find uncovered groups
 *     auto uncovered = db.get_uncovered_groups();
 *     std::cout << "Uncovered groups: " << uncovered.size() << std::endl;
 * }
 * ```
 */
class COVERAGE_PARSER_API GroupsParser : public BaseParser {
public:
    GroupsParser() = default;
    ~GroupsParser() override = default;
    
    ParserResult parse(const std::string& filename, CoverageDatabase& db) override;
    std::string get_parser_info() const override { return "Groups Parser v1.0"; }
    
private:
    ParserResult parse_header_section(std::ifstream& file);
    ParserResult parse_group_entry(const std::string& line, CoverageDatabase& db);
    bool is_group_data_line(const std::string& line) const;
    bool is_header_line(const std::string& line) const;
    std::vector<std::string> split_group_line(const std::string& line) const;
};

/**
 * @brief Hierarchy parser for hierarchy.txt files
 * 
 * Parses hierarchy coverage files containing design hierarchy
 * coverage data for each instance in the design.
 * 
 * OUTPUT DATA STRUCTURE:
 * Creates HierarchyInstance objects for each design instance containing:
 * - instance_path: Full hierarchical path ("top.cpu.alu")
 * - module_name: Module/block name ("alu")
 * - total_score: Instance total coverage score
 * - assert_coverage: Assertion coverage for this instance
 * - group_coverage: Group coverage for this instance (if available)
 * - depth_level: Hierarchy depth (0=top, 1=level1, etc.)
 * - is_leaf_instance: True if this is a leaf node
 * 
 * SUPPORTED FILE FORMATS:
 * - URG hierarchy.txt files
 * - VCS design hierarchy reports
 * - Instance-based coverage summaries
 * 
 * EXAMPLE USAGE:
 * ```cpp
 * HierarchyParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("hierarchy.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     std::cout << "Parsed " << db.get_num_hierarchy_instances() << " instances" << std::endl;
 *     
 *     // Find specific instance
 *     auto instance = db.find_hierarchy_instance("top.cpu.alu");
 *     if (instance) {
 *         std::cout << "Instance: " << instance->instance_path << std::endl;
 *         std::cout << "Module: " << instance->module_name << std::endl;
 *         std::cout << "Depth: " << instance->depth_level << std::endl;
 *         std::cout << "Score: " << instance->total_score << "%" << std::endl;
 *     }
 * }
 * ```
 */
class COVERAGE_PARSER_API HierarchyParser : public BaseParser {
public:
    HierarchyParser() = default;
    ~HierarchyParser() override = default;
    
    ParserResult parse(const std::string& filename, CoverageDatabase& db) override;
    std::string get_parser_info() const override { return "Hierarchy Parser v1.0"; }
    
private:
    ParserResult parse_hierarchy_entry(const std::string& line, CoverageDatabase& db);
    bool is_hierarchy_data_line(const std::string& line) const;
    bool is_header_line(const std::string& line) const;
    std::vector<std::string> split_hierarchy_line(const std::string& line) const;
    std::uint32_t calculate_depth_level(const std::string& instance_path) const;
};

/**
 * @brief Module list parser for modlist.txt files
 * 
 * Parses module list coverage files containing module definition
 * coverage data aggregated across all instances.
 * 
 * OUTPUT DATA STRUCTURE:
 * Creates ModuleDefinition objects for each module type containing:
 * - module_name: Module definition name ("cpu_core")
 * - total_score: Module total coverage score
 * - assert_coverage: Assertion coverage for this module
 * - group_coverage: Group coverage for this module (if available)
 * - instance_count: Number of instances of this module
 * - covered_instances: Number of instances with coverage
 * 
 * SUPPORTED FILE FORMATS:
 * - URG modlist.txt files
 * - VCS module definition reports
 * - Module-based coverage summaries
 * 
 * EXAMPLE USAGE:
 * ```cpp
 * ModuleListParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("modlist.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     std::cout << "Parsed " << db.get_num_modules() << " module definitions" << std::endl;
 *     
 *     // Find specific module
 *     auto module = db.find_module_definition("cpu_core");
 *     if (module) {
 *         std::cout << "Module: " << module->module_name << std::endl;
 *         std::cout << "Score: " << module->total_score << "%" << std::endl;
 *         std::cout << "Instances: " << module->instance_count << std::endl;
 *         
 *         if (module->is_fully_covered()) {
 *             std::cout << "✓ All instances covered!" << std::endl;
 *         }
 *     }
 * }
 * ```
 */
class COVERAGE_PARSER_API ModuleListParser : public BaseParser {
public:
    ModuleListParser() = default;
    ~ModuleListParser() override = default;
    
    ParserResult parse(const std::string& filename, CoverageDatabase& db) override;
    std::string get_parser_info() const override { return "Module List Parser v1.0"; }
    
private:
    ParserResult parse_module_entry(const std::string& line, CoverageDatabase& db);
    bool is_module_data_line(const std::string& line) const;
    bool is_header_line(const std::string& line) const;
    std::vector<std::string> split_module_line(const std::string& line) const;
};

/**
 * @brief Assert parser for asserts.txt files
 * 
 * Parses assertion coverage files containing individual assertion
 * coverage information and hit counts.
 * 
 * OUTPUT DATA STRUCTURE:
 * Creates AssertCoverage objects for each assertion containing:
 * - assert_name: Assertion name/identifier
 * - instance_path: Instance where assertion exists
 * - file_location: Source file location
 * - line_number: Line number in source file
 * - is_covered: Coverage status (true if hit)
 * - hit_count: Number of times assertion was hit
 * - severity: Assertion severity level ("PASS", "FAIL", etc.)
 * - message: Assertion message/description
 * 
 * SUPPORTED FILE FORMATS:
 * - URG asserts.txt files
 * - VCS assertion coverage reports
 * - SystemVerilog assertion summaries
 * 
 * EXAMPLE USAGE:
 * ```cpp
 * AssertParser parser;
 * CoverageDatabase db;
 * 
 * ParserResult result = parser.parse("asserts.txt", db);
 * if (result == ParserResult::SUCCESS) {
 *     std::cout << "Parsed " << db.get_num_asserts() << " assertions" << std::endl;
 *     
 *     // Find uncovered assertions
 *     uint32_t uncovered_count = 0;
 *     for (const auto& [name, assert_cov] : db.asserts_table) {
 *         if (!assert_cov->is_covered) {
 *             uncovered_count++;
 *             std::cout << "✗ " << assert_cov->assert_name 
 *                       << " at " << assert_cov->get_full_location() << std::endl;
 *         }
 *     }
 *     std::cout << "Uncovered assertions: " << uncovered_count << std::endl;
 * }
 * ```
 */
class COVERAGE_PARSER_API AssertParser : public BaseParser {
public:
    AssertParser() = default;
    ~AssertParser() override = default;
    
    ParserResult parse(const std::string& filename, CoverageDatabase& db) override;
    std::string get_parser_info() const override { return "Assert Parser v1.0"; }
    
private:
    ParserResult parse_assert_entry(const std::string& line, CoverageDatabase& db);
    bool is_assert_data_line(const std::string& line) const;
    bool is_header_line(const std::string& line) const;
    std::vector<std::string> split_assert_line(const std::string& line) const;
};

/**
 * @defgroup Utilities Utility Functions
 * @brief Utility functions for error handling and data export
 * @{
 */

/**
 * @brief Get human-readable error string for parser result
 * @param result Parser result code
 * @return String describing the error
 */
COVERAGE_PARSER_API std::string get_error_string(ParserResult result);

/**
 * @brief Print coverage summary to output stream
 * @param stats Statistics to print
 * @param output Output stream to write to
 * @return ParserResult indicating success or failure
 */
COVERAGE_PARSER_API ParserResult print_coverage_summary(const CoverageStatistics& stats, std::ostream& output);

/**
 * @brief Export coverage data to CSV format
 * @param db Database to export
 * @param filename Output CSV filename
 * @return ParserResult indicating success or failure
 */
COVERAGE_PARSER_API ParserResult export_coverage_to_csv(const CoverageDatabase& db, const std::string& filename);

/**
 * @brief Export coverage data to XML format
 * @param db Database to export
 * @param filename Output XML filename
 * @return ParserResult indicating success or failure
 */
COVERAGE_PARSER_API ParserResult export_coverage_to_xml(const CoverageDatabase& db, const std::string& filename);

/**
 * @brief Export coverage data to JSON format
 * @param db Database to export
 * @param filename Output JSON filename
 * @return ParserResult indicating success or failure
 */
COVERAGE_PARSER_API ParserResult export_coverage_to_json(const CoverageDatabase& db, const std::string& filename);

/**
 * @brief Generate HTML coverage report
 * @param db Database to report
 * @param output_dir Directory for HTML files
 * @param report_title Title for the report
 * @return ParserResult indicating success or failure
 */
COVERAGE_PARSER_API ParserResult generate_html_report(const CoverageDatabase& db, 
                                                      const std::string& output_dir,
                                                      const std::string& report_title);

/**
 * @brief Validate coverage database integrity
 * @param db Database to validate
 * @return ParserResult indicating validation result
 */
COVERAGE_PARSER_API ParserResult validate_database(const CoverageDatabase& db);

/**
 * @brief Get memory usage statistics
 * @param total_bytes Pointer to store total allocated bytes
 * @param num_allocations Pointer to store number of active allocations
 * @return ParserResult indicating success or failure
 */
COVERAGE_PARSER_API ParserResult get_memory_usage(std::size_t& total_bytes, std::uint32_t& num_allocations);

/** @} */

/**
 * @defgroup Factory Factory Functions
 * @brief Factory functions for creating parsers and configurations
 * @{
 */

/**
 * @brief Create a parser based on file type detection
 * @param filename Path to the file to determine parser type
 * @return Unique pointer to appropriate parser, nullptr if type cannot be determined
 */
COVERAGE_PARSER_API std::unique_ptr<BaseParser> create_parser_for_file(const std::string& filename);

/**
 * @brief Create parser configuration with default settings
 * @return Default parser configuration
 */
COVERAGE_PARSER_API ParserConfig create_default_config();

/**
 * @brief Create parser configuration optimized for fast parsing
 * @return Fast parsing configuration
 */
COVERAGE_PARSER_API ParserConfig create_fast_config();

/**
 * @brief Create parser configuration for detailed analysis
 * @return Detailed analysis configuration
 */
COVERAGE_PARSER_API ParserConfig create_detailed_config();

/** @} */

/**
 * @namespace utils
 * @brief Utility functions for coverage parsing
 * 
 * This namespace contains helper functions used throughout the coverage
 * parsing library for common operations like string manipulation, file
 * handling, number parsing, and coverage calculations.
 */
namespace utils {

/**
 * @defgroup StringUtils String Utilities
 * @brief String manipulation and parsing functions
 * @{
 */

/// Trim whitespace from both ends of a string
std::string trim(const std::string& str);

/// Split string by delimiter
std::vector<std::string> split(const std::string& str, char delimiter);

/// Split string by whitespace
std::vector<std::string> split_whitespace(const std::string& str);

/// Convert string to lowercase
std::string to_lower(const std::string& str);

/// Remove quotes from string
std::string remove_quotes(const std::string& str);

/** @} */

/**
 * @defgroup NumberUtils Number Parsing Utilities
 * @brief Number parsing and validation functions
 * @{
 */

/// Parse percentage string to double
double parse_percentage(const std::string& str);

/// Parse string to integer with default value
int parse_int(const std::string& str, int default_value = 0);

/// Parse string to unsigned integer with default value
unsigned int parse_uint(const std::string& str, unsigned int default_value = 0);

/// Parse string to double with default value
double parse_double(const std::string& str, double default_value = 0.0);

/// Check if string represents a valid number
bool is_number(const std::string& str);

/** @} */

/**
 * @defgroup CoverageUtils Coverage Calculation Utilities
 * @brief Coverage-specific calculation functions
 * @{
 */

/// Calculate coverage percentage
double calculate_coverage_percentage(unsigned int covered, unsigned int total);

/// Get coverage status string based on percentage
std::string get_coverage_status(double percentage);

/** @} */

/**
 * @defgroup PathUtils Path Utilities
 * @brief Path manipulation and file handling functions
 * @{
 */

/// Normalize path separators
std::string normalize_path(const std::string& path);

/// Get filename from path
std::string get_filename(const std::string& path);

/// Get directory from path
std::string get_directory(const std::string& path);

/** @} */

/**
 * @defgroup FileUtils File Utilities
 * @brief File system operations
 * @{
 */

/// Check if file exists
bool file_exists(const std::string& filepath);

/// Get file size in bytes
std::size_t get_file_size(const std::string& filepath);

/** @} */

/**
 * @defgroup FormatUtils Formatting Utilities
 * @brief Number and text formatting functions
 * @{
 */

/// Format number with thousands separators
std::string format_number(unsigned long number);

/// Parse datetime string
std::chrono::system_clock::time_point parse_datetime(const std::string& datetime_str);

/** @} */

} // namespace utils

} // namespace coverage_parser

#endif /* FUNCTIONAL_COVERAGE_PARSER_H */